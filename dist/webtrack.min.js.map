{"version":3,"sources":["node_modules/browser-pack/_prelude.js","webtrack.min.js","modules/webtrack.js"],"names":["f","exports","_typeof","module","define","amd","window","global","self","this","WebTrack","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","_toConsumableArray","arr","Array","isArray","_arrayLikeToArray","_arrayWithoutHoles","iter","Symbol","iterator","Object","from","_iterableToArray","minLen","prototype","toString","slice","constructor","name","test","_unsupportedIterableToArray","TypeError","_nonIterableSpread","g","len","arr2","ownKeys","object","enumerableOnly","symbols","keys","getOwnPropertySymbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","arguments","source","forEach","key","obj","value","defineProperty","configurable","writable","getOwnPropertyDescriptors","defineProperties","_defineProperties","props","descriptor","_classPrivateFieldGet","receiver","privateMap","get","_classPrivateFieldSet","set","_formatName","WeakMap","_formatVersion","_reformatedTracks","_waypoints","_bufferSize","_pointsWithEle","_pointsWithoutEle","_currentPos","_view","instance","Constructor","_classCallCheck","_buffer","_defineProperty","protoProps","staticProps","gpxString","_this","xmlSource","DOMParser","parseFromString","trim","trks","querySelectorAll","prevPt","min","Number","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","gain","loss","trk","trackpoints","trkpts","segment","isFirst","prevEle","trkpt","pt","lat","parseFloat","getAttribute","lon","ele","_getElementValue","cumulDist","distanceBetween","diff","webPt","gpsToWeb","withEle","points","concat","_trackInfo","getTrackLength","wpt","time","coords","Date","_totalWaypoints","_fmtArraySize","_trksArraySize","_wptsArraySize","createBuffer","parent","needle","elem","querySelector","undefined","innerHTML","childNodes","data","wpt1","wpt2","latlng1","latlng2","rad","Math","PI","lat1","lat2","sinDLat","sin","sinDLon","cos","atan2","sqrt","_fmtText","totalSegments","trksArraySize","wptsArraySize","waypoint","_this$currentPos","setUint8","_this$currentPos2","getUint8","setUint16","pos","getUint16","setInt16","getInt16","setUint32","getUint32","setInt32","getInt32","atanh","trackPoints","withoutEle","lastSegment","_this2","ArrayBuffer","DataView","enc","TextEncoder","encoded","encode","separator","fmtText","_wUint8","_wUint16","_wUint32","round","someTracksWithEle","_wInt16","errorDeltaX","errorDeltaY","prevPoint","point","_wInt32","deltaX","deltaY","dec","TextDecoder","fmtInput","Uint8Array","decode","webtrackBytes","typedBuffer","_formatInfoPass","_rUint8","_rUint16","currSegType","_rUint32","_rInt16","_i","totalPointsInSegment","segWithEle","_rInt32","_i2","bytes","_c"],"mappings":"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","file":"webtrack.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.WebTrack = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\"use strict\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError(\"attempted to get private field on non-instance\"); } if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError(\"attempted to set private field on non-instance\"); } if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\nvar _formatName = new WeakMap();\n\nvar _formatVersion = new WeakMap();\n\nvar _reformatedTracks = new WeakMap();\n\nvar _waypoints = new WeakMap();\n\nvar _trackInfo = new WeakMap();\n\nvar _buffer = new WeakMap();\n\nvar _bufferSize = new WeakMap();\n\nvar _pointsWithEle = new WeakMap();\n\nvar _pointsWithoutEle = new WeakMap();\n\nvar _currentPos = new WeakMap();\n\nvar _totalWaypoints = new WeakMap();\n\nvar _view = new WeakMap();\n\n/*!\n * MIT License\n *\n * Copyright (c) 2020 Clement\n * Copyright (c) 2018 Lucas Trebouet Voisin\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/** Interface with the WebTrack file format. */\nvar WebTrack = /*#__PURE__*/function () {\n  function WebTrack() {\n    _classCallCheck(this, WebTrack);\n\n    _formatName.set(this, {\n      writable: true,\n      value: \"webtrack-bin\"\n    });\n\n    _formatVersion.set(this, {\n      writable: true,\n      value: \"0.0.1\"\n    });\n\n    _reformatedTracks.set(this, {\n      writable: true,\n      value: []\n    });\n\n    _waypoints.set(this, {\n      writable: true,\n      value: []\n    });\n\n    _trackInfo.set(this, {\n      writable: true,\n      value: {}\n    });\n\n    _buffer.set(this, {\n      writable: true,\n      value: null\n    });\n\n    _bufferSize.set(this, {\n      writable: true,\n      value: 0\n    });\n\n    _pointsWithEle.set(this, {\n      writable: true,\n      value: 0\n    });\n\n    _pointsWithoutEle.set(this, {\n      writable: true,\n      value: 0\n    });\n\n    _currentPos.set(this, {\n      writable: true,\n      value: 0\n    });\n\n    _totalWaypoints.set(this, {\n      writable: true,\n      value: 0\n    });\n\n    _view.set(this, {\n      writable: true,\n      value: void 0\n    });\n  }\n\n  _createClass(WebTrack, [{\n    key: \"loadGPX\",\n\n    /**\n     * Load a GPX string and create a WebTrack buffer.\n     * @param gpxString The GPX string.\n     * @return this\n     */\n    value: function loadGPX(gpxString) {\n      var _this = this;\n\n      _classPrivateFieldSet(this, _reformatedTracks, []);\n\n      _classPrivateFieldSet(this, _waypoints, []);\n\n      _classPrivateFieldSet(this, _pointsWithEle, 0);\n\n      _classPrivateFieldSet(this, _pointsWithoutEle, 0);\n\n      var domParser = new window.DOMParser();\n      var xmlSource = domParser.parseFromString(gpxString.trim(), \"text/xml\");\n      var trks = [].slice.call(xmlSource.querySelectorAll(\"trk\"));\n      var prevPt = {};\n      var min = Number.POSITIVE_INFINITY,\n          max = Number.NEGATIVE_INFINITY,\n          gain = 0,\n          loss = 0;\n      trks.forEach(function (trk) {\n        // loop over <trk/>\n        var trackpoints = [];\n        var trkpts = [].slice.call(trk.querySelectorAll(\"trkpt\"));\n        var segment = {};\n        var isFirst = true;\n        var prevEle = null;\n        trkpts.forEach(function (trkpt) {\n          // loop over <trkpt/>\n          var pt = {};\n          pt.lat = parseFloat(trkpt.getAttribute(\"lat\"));\n          pt.lon = parseFloat(trkpt.getAttribute(\"lon\"));\n          pt.ele = parseFloat(_this._getElementValue(trkpt, \"ele\")) || null;\n\n          if (Object.keys(prevPt).length === 0 && prevPt.constructor === Object) {\n            pt.cumulDist = 0.0;\n          } else {\n            pt.cumulDist = //$FlowIgnore[unsafe-addition] operation with satisfying conditions\n            prevPt.cumulDist + _this.distanceBetween(prevPt, pt);\n          }\n\n          prevPt = _objectSpread({}, pt);\n          trackpoints.push(pt);\n\n          var webPt = _this.gpsToWeb(pt.lon, pt.lat);\n\n          if (isFirst) {\n            if (pt.ele === null) {\n              segment.withEle = false;\n              segment.points = [[].concat(_toConsumableArray(webPt), [pt.cumulDist])];\n            } else {\n              segment.withEle = true;\n              segment.points = [[].concat(_toConsumableArray(webPt), [pt.cumulDist, pt.ele])];\n            }\n\n            isFirst = false;\n          } else {\n            if (pt.ele === null) {\n              if (segment.withEle) {\n                // split\n                _classPrivateFieldSet(_this, _pointsWithEle, _classPrivateFieldGet(_this, _pointsWithEle) + segment.points.length);\n\n                _classPrivateFieldGet(_this, _reformatedTracks).push(segment);\n\n                segment = {}; // fresh segment\n\n                segment.withEle = false;\n                segment.points = [[].concat(_toConsumableArray(webPt), [pt.cumulDist])];\n              } else {\n                segment.points.push([].concat(_toConsumableArray(webPt), [pt.cumulDist]));\n              }\n            } else {\n              if (!segment.withEle) {\n                _classPrivateFieldSet(_this, _pointsWithoutEle, _classPrivateFieldGet(_this, _pointsWithoutEle) + segment.points.length);\n\n                _classPrivateFieldGet(_this, _reformatedTracks).push(segment);\n\n                segment = {};\n                segment.withEle = true;\n                segment.points = [[].concat(_toConsumableArray(webPt), [pt.cumulDist, pt.ele])];\n              } else {\n                segment.points.push([].concat(_toConsumableArray(webPt), [pt.cumulDist, pt.ele]));\n              }\n            }\n          }\n\n          if (pt.ele !== null) {\n            if (prevEle !== null) {\n              //$FlowIgnore[unsafe-addition]\n              var diff = pt.ele - prevEle;\n\n              if (diff < 0) {\n                loss -= diff;\n              } else if (diff > 0) {\n                gain += diff;\n              }\n            } //$FlowIgnore[invalid-compare]\n\n\n            if (min > pt.ele) {\n              min = pt.ele;\n            } //$FlowIgnore[invalid-compare]\n\n\n            if (max < pt.ele) {\n              max = pt.ele;\n            }\n\n            prevEle = pt.ele;\n          }\n        });\n\n        if (segment) {\n          if (segment.withEle) {\n            _classPrivateFieldSet(_this, _pointsWithEle, _classPrivateFieldGet(_this, _pointsWithEle) + segment.points.length);\n          } else {\n            _classPrivateFieldSet(_this, _pointsWithoutEle, _classPrivateFieldGet(_this, _pointsWithoutEle) + segment.points.length);\n          }\n\n          _classPrivateFieldGet(_this, _reformatedTracks).push(segment);\n        }\n\n        if (_classPrivateFieldGet(_this, _reformatedTracks).length > 255) {\n          throw \"Failed to load the GPX string: exceeding 255 segments\";\n        }\n      });\n\n      _classPrivateFieldSet(this, _trackInfo, {\n        length: this.getTrackLength(),\n        min: min,\n        max: max,\n        gain: gain,\n        loss: loss\n      });\n\n      var wpts = [].slice.call(xmlSource.querySelectorAll(\"wpt\"));\n      wpts.forEach(function (wpt) {\n        // loop over <wpt/>\n        var time = _this._getElementValue(wpt, \"time\");\n\n        var coords = _this.gpsToWeb(parseFloat(wpt.getAttribute(\"lon\")), parseFloat(wpt.getAttribute(\"lat\")));\n\n        _classPrivateFieldGet(_this, _waypoints).push({\n          name: _this._getElementValue(wpt, \"name\") || null,\n          sym: _this._getElementValue(wpt, \"sym\") || null,\n          lon: coords[0],\n          lat: coords[1],\n          ele: parseFloat(_this._getElementValue(wpt, \"ele\")) || null,\n          time: time == null ? null : new Date(time)\n        });\n      });\n\n      _classPrivateFieldSet(this, _totalWaypoints, _classPrivateFieldGet(this, _waypoints).length);\n\n      _classPrivateFieldSet(this, _bufferSize, this._fmtArraySize() + this._trksArraySize() + this._wptsArraySize());\n\n      this.createBuffer();\n      return this;\n    }\n    /**\n     * Get value from a XML DOM element\n     *\n     * @param  {Element} parent - Parent DOM Element\n     * @param  {string} needle - Name of the searched element\n     *\n     * @return The element value\n     */\n\n  }, {\n    key: \"_getElementValue\",\n    value: function _getElementValue(parent, needle) {\n      var elem = parent.querySelector(needle);\n\n      if (elem != null) {\n        return elem.innerHTML != undefined ? elem.innerHTML : //$FlowIgnore[prop-missing]\n        elem.childNodes[0].data;\n      }\n\n      return elem;\n    }\n    /**\n     * Compute the dstance between two points.\n     *\n     * @param  {WayPoint} wpt1 - A geographic point with lat and lon properties\n     * @param  {WayPoint} wpt2 - A geographic point with lat and lon properties\n     *\n     * @returns {float} The distance between the two points\n     */\n\n  }, {\n    key: \"distanceBetween\",\n    value: function distanceBetween(wpt1, wpt2) {\n      var latlng1 = {};\n      latlng1.lat = wpt1.lat;\n      latlng1.lon = wpt1.lon;\n      var latlng2 = {};\n      latlng2.lat = wpt2.lat;\n      latlng2.lon = wpt2.lon;\n      var rad = Math.PI / 180,\n          lat1 = latlng1.lat * rad,\n          lat2 = latlng2.lat * rad,\n          sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),\n          sinDLon = Math.sin((latlng2.lon - latlng1.lon) * rad / 2),\n          a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,\n          c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n      return 6371008 * c;\n    }\n    /**\n     * Returns the first characters that should be in the WebTrack file.\n     * Example: 'webtrack-bin:0.1.2:'\n     * @return ASCII characters.\n     */\n\n  }, {\n    key: \"_fmtText\",\n    value: function _fmtText() {\n      return \"\".concat(_classPrivateFieldGet(this, _formatName), \":\").concat(_classPrivateFieldGet(this, _formatVersion), \":\");\n    }\n    /**\n     * Returns the length in bytes of the \"Format Information\" section.\n     * @return Number of bytes.\n     */\n\n  }, {\n    key: \"_fmtArraySize\",\n    value: function _fmtArraySize() {\n      return this._fmtText().length + 3;\n    }\n    /**\n     * Returns the length in bytes of the \"Segment Headers\",\n     * plus the \"Track Information\", plus the \"Segment\" sections.\n     * @return Number of bytes.\n     */\n\n  }, {\n    key: \"_trksArraySize\",\n    value: function _trksArraySize() {\n      var totalSegments = _classPrivateFieldGet(this, _reformatedTracks).length;\n\n      var trksArraySize = 0;\n\n      if (totalSegments > 0) {\n        // segment headers:\n        trksArraySize += totalSegments * 5; // tracks info (length):\n\n        trksArraySize += 4;\n\n        if (_classPrivateFieldGet(this, _pointsWithEle) > 0) {\n          // tracks info (ele min/max/gain/loss):\n          trksArraySize += 12;\n        }\n\n        trksArraySize += totalSegments * 4 + _classPrivateFieldGet(this, _pointsWithoutEle) * 6 + _classPrivateFieldGet(this, _pointsWithEle) * 8;\n      }\n\n      return trksArraySize;\n    }\n    /**\n     * Returns the length in bytes of the \"Waypoints\" section.\n     * @return Number of bytes.\n     */\n\n  }, {\n    key: \"_wptsArraySize\",\n    value: function _wptsArraySize() {\n      var wptsArraySize = 0;\n\n      _classPrivateFieldGet(this, _waypoints).forEach(function (waypoint) {\n        wptsArraySize += 11 + (waypoint.ele ? 2 : 0) + (waypoint.sym ? waypoint.sym.length : 0) + (waypoint.name ? waypoint.name.length : 0);\n      });\n\n      return wptsArraySize;\n    }\n    /**\n     * Returns true if there is at least one point with elevation data.\n     * @return False if there isn't a single point with elevation, true otherwise.\n     */\n\n  }, {\n    key: \"someTracksWithEle\",\n    value: function someTracksWithEle() {\n      return _classPrivateFieldGet(this, _pointsWithEle) > 0;\n    }\n    /**\n     * Returns the size of the buffer.\n     * @return Number of bytes.\n     */\n\n  }, {\n    key: \"getBufferSize\",\n    value: function getBufferSize() {\n      return _classPrivateFieldGet(this, _bufferSize);\n    }\n    /**\n     * Append a uint8 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n\n  }, {\n    key: \"_wUint8\",\n    value: function _wUint8(data) {\n      var _this$currentPos;\n\n      _classPrivateFieldGet(this, _view).setUint8((_classPrivateFieldSet(this, _currentPos, (_this$currentPos = +_classPrivateFieldGet(this, _currentPos)) + 1), _this$currentPos), data);\n    }\n    /**\n     * Read a uint8 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The byte from the buffer.\n     */\n\n  }, {\n    key: \"_rUint8\",\n    value: function _rUint8() {\n      var _this$currentPos2;\n\n      return _classPrivateFieldGet(this, _view).getUint8((_classPrivateFieldSet(this, _currentPos, (_this$currentPos2 = +_classPrivateFieldGet(this, _currentPos)) + 1), _this$currentPos2));\n    }\n    /**\n     * Append a uint16 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n\n  }, {\n    key: \"_wUint16\",\n    value: function _wUint16(data) {\n      _classPrivateFieldGet(this, _view).setUint16(_classPrivateFieldGet(this, _currentPos), data, false);\n\n      _classPrivateFieldSet(this, _currentPos, _classPrivateFieldGet(this, _currentPos) + 2);\n    }\n    /**\n     * Read a uint16 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The bytes from the buffer.\n     */\n\n  }, {\n    key: \"_rUint16\",\n    value: function _rUint16() {\n      var pos = _classPrivateFieldGet(this, _currentPos);\n\n      _classPrivateFieldSet(this, _currentPos, _classPrivateFieldGet(this, _currentPos) + 2);\n\n      return _classPrivateFieldGet(this, _view).getUint16(pos, false);\n    }\n    /**\n     * Append a int16 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n\n  }, {\n    key: \"_wInt16\",\n    value: function _wInt16(data) {\n      _classPrivateFieldGet(this, _view).setInt16(_classPrivateFieldGet(this, _currentPos), data, false);\n\n      _classPrivateFieldSet(this, _currentPos, _classPrivateFieldGet(this, _currentPos) + 2);\n    }\n    /**\n     * Read a int16 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The bytes from the buffer.\n     */\n\n  }, {\n    key: \"_rInt16\",\n    value: function _rInt16() {\n      var pos = _classPrivateFieldGet(this, _currentPos);\n\n      _classPrivateFieldSet(this, _currentPos, _classPrivateFieldGet(this, _currentPos) + 2);\n\n      return _classPrivateFieldGet(this, _view).getInt16(pos, false);\n    }\n    /**\n     * Append a uint32 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n\n  }, {\n    key: \"_wUint32\",\n    value: function _wUint32(data) {\n      _classPrivateFieldGet(this, _view).setUint32(_classPrivateFieldGet(this, _currentPos), data, false);\n\n      _classPrivateFieldSet(this, _currentPos, _classPrivateFieldGet(this, _currentPos) + 4);\n    }\n    /**\n     * Read a uint32 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The bytes from the buffer.\n     */\n\n  }, {\n    key: \"_rUint32\",\n    value: function _rUint32() {\n      var pos = _classPrivateFieldGet(this, _currentPos);\n\n      _classPrivateFieldSet(this, _currentPos, _classPrivateFieldGet(this, _currentPos) + 4);\n\n      return _classPrivateFieldGet(this, _view).getUint32(pos, false);\n    }\n    /**\n     * Append a int32 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n\n  }, {\n    key: \"_wInt32\",\n    value: function _wInt32(data) {\n      _classPrivateFieldGet(this, _view).setInt32(_classPrivateFieldGet(this, _currentPos), data, false);\n\n      _classPrivateFieldSet(this, _currentPos, _classPrivateFieldGet(this, _currentPos) + 4);\n    }\n    /**\n     * Read a int32 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The bytes from the buffer.\n     */\n\n  }, {\n    key: \"_rInt32\",\n    value: function _rInt32() {\n      var pos = _classPrivateFieldGet(this, _currentPos);\n\n      _classPrivateFieldSet(this, _currentPos, _classPrivateFieldGet(this, _currentPos) + 4);\n\n      return _classPrivateFieldGet(this, _view).getInt32(pos, false);\n    }\n    /**\n     * Projection of a GPS point (EPSG:4326) into the Web Mercator (EPSG:3857).\n     * Formula based on:\n     * Title: Implementation Practice Web Mercator Map Projection\n     * Reference: NGA.SIG.0011_1.0.0_WEBMERC, 2014-02-18\n     * Author: National Geospatial Intelligence Agency (NGA)\n     * @param lon GPS longitude\n     * @param lat GPS latitude\n     * @return Web Mercator coordinates [easting, northing]\n     */\n\n  }, {\n    key: \"gpsToWeb\",\n    value: function gpsToWeb(lon, lat) {\n      var rad = Math.PI / 180; // ellipsoid semi-major axis [WSG 84 = 6378137m]:\n\n      var a = 6378137; // no parseInt to reduce drift when substracting coordinates:\n\n      return [// easting coordinate in the Web Mercator:\n      lon * a * rad, // northing coordinate in the Web Mercator:\n      a * Math.atanh(Math.sin(lat * rad))];\n    }\n    /**\n     * Returns essential information about the track.\n     */\n\n  }, {\n    key: \"getTrackInfo\",\n    value: function getTrackInfo() {\n      return _objectSpread(_objectSpread({}, _classPrivateFieldGet(this, _trackInfo)), {}, {\n        trackPoints: {\n          withEle: _classPrivateFieldGet(this, _pointsWithEle),\n          withoutEle: _classPrivateFieldGet(this, _pointsWithoutEle)\n        }\n      });\n    }\n    /**\n     * Returns an array of segments in the WebTrack format.\n     */\n\n  }, {\n    key: \"getTrack\",\n    value: function getTrack() {\n      return _classPrivateFieldGet(this, _reformatedTracks);\n    }\n    /**\n     * Returns an array of waypoints in the WebTrack format.\n     */\n\n  }, {\n    key: \"getWaypoints\",\n    value: function getWaypoints() {\n      return _classPrivateFieldGet(this, _waypoints);\n    }\n    /**\n     * Returns the length of the whole track.\n     */\n\n  }, {\n    key: \"getTrackLength\",\n    value: function getTrackLength() {\n      var lastSegment = _classPrivateFieldGet(this, _reformatedTracks)[_classPrivateFieldGet(this, _reformatedTracks).length - 1].points;\n\n      return lastSegment[lastSegment.length - 1][2];\n    }\n    /**\n     * Create a WebTrack buffer with the data fetched from the GPX string.\n     * @return A WebTrack buffer ready to be stored.\n     */\n\n  }, {\n    key: \"createBuffer\",\n    value: function createBuffer() {\n      var _this2 = this;\n\n      if (_classPrivateFieldGet(this, _bufferSize) == 0) {\n        throw \"Failed to create the WebTrack buffer: empty buffer\";\n      }\n\n      _classPrivateFieldSet(this, _buffer, new ArrayBuffer(_classPrivateFieldGet(this, _bufferSize)));\n\n      _classPrivateFieldSet(this, _view, new DataView(_classPrivateFieldGet(this, _buffer)));\n\n      var enc = new TextEncoder();\n      var encoded = {\n        withEle: enc.encode(\"E\")[0],\n        withoutEle: enc.encode(\"F\")[0],\n        separator: enc.encode(\"\\n\")[0]\n      }; // Format Information:\n\n      var fmtText = enc.encode(this._fmtText());\n\n      _classPrivateFieldSet(this, _currentPos, 0);\n\n      fmtText.forEach(function (c) {\n        _this2._wUint8(c);\n      });\n\n      var totalSegments = _classPrivateFieldGet(this, _reformatedTracks).length;\n\n      if (totalSegments > 255) {\n        throw \"Failed to create the WebTrack buffer: too many segments\";\n      }\n\n      this._wUint8(totalSegments);\n\n      if (_classPrivateFieldGet(this, _totalWaypoints) > 65535) {\n        throw \"Failed to create the WebTrack buffer: too many waypoints\";\n      }\n\n      this._wUint16(_classPrivateFieldGet(this, _totalWaypoints)); // Segment Headers:\n\n\n      _classPrivateFieldGet(this, _reformatedTracks).forEach(function (segment) {\n        var c = segment.withEle ? encoded.withEle : encoded.withoutEle;\n\n        _this2._wUint8(c); // Number of points written in big-endian:\n\n\n        _this2._wUint32(segment.points.length);\n      }); // Track Information:\n\n\n      this._wUint32(Math.round(_classPrivateFieldGet(this, _trackInfo).length));\n\n      if (this.someTracksWithEle()) {\n        //$FlowIgnore[incompatible-call] condition satisfied\n        this._wInt16(Math.round(_classPrivateFieldGet(this, _trackInfo).min)); //$FlowIgnore[incompatible-call] condition satisfied\n\n\n        this._wInt16(Math.round(_classPrivateFieldGet(this, _trackInfo).max)); //$FlowIgnore[incompatible-call] condition satisfied\n\n\n        this._wUint32(Math.round(_classPrivateFieldGet(this, _trackInfo).gain)); //$FlowIgnore[incompatible-call] condition satisfied\n\n\n        this._wUint32(Math.round(_classPrivateFieldGet(this, _trackInfo).loss));\n      } // Points from segments:\n\n\n      var errorDeltaX = 0,\n          errorDeltaY = 0;\n\n      _classPrivateFieldGet(this, _reformatedTracks).forEach(function (segment) {\n        var prevPoint = null;\n        segment.points.forEach(function (point) {\n          if (prevPoint === null) {\n            _this2._wInt32(Math.round(point[0]));\n\n            _this2._wInt32(Math.round(point[1])); // cumulated distance:\n\n\n            _this2._wUint16(Math.round(point[2] / 10));\n\n            errorDeltaX = 0;\n            errorDeltaY = 0;\n          } else {\n            // offset with drift correction\n            var deltaX = point[0] - prevPoint[0] + errorDeltaX,\n                deltaY = point[1] - prevPoint[1] + errorDeltaY;\n            var minDelta = -32768,\n                maxDelta = 32767;\n\n            if (deltaX > maxDelta || deltaX < minDelta || deltaY > maxDelta || deltaY < minDelta) {\n              throw \"Failed to create the WebTrack buffer: offset out or range\";\n            }\n\n            _this2._wInt16(Math.round(deltaX));\n\n            _this2._wInt16(Math.round(deltaY)); // rounding positions create a drift corrected on the next point(s)\n\n\n            errorDeltaX = deltaX - Math.round(deltaX);\n            errorDeltaY = deltaY - Math.round(deltaY);\n\n            _this2._wUint16(Math.round(point[2] / 10));\n          }\n\n          prevPoint = point;\n\n          if (segment.withEle) {\n            _this2._wInt16(Math.round(point[3]));\n          }\n        });\n      }); // Points from waypoints:\n\n\n      _classPrivateFieldGet(this, _waypoints).forEach(function (waypoint) {\n        _this2._wInt32(Math.round(waypoint.lon));\n\n        _this2._wInt32(Math.round(waypoint.lat));\n\n        _this2._wUint8(waypoint.ele ? encoded.withEle : encoded.withoutEle);\n\n        if (waypoint.ele) {\n          _this2._wInt16(Math.round(waypoint.ele));\n        }\n\n        if (waypoint.sym) {\n          var symText = enc.encode(waypoint.sym);\n          symText.forEach(function (c) {\n            _this2._wUint8(c);\n          });\n        }\n\n        _this2._wUint8(encoded.separator);\n\n        if (waypoint.name) {\n          var nameText = enc.encode(waypoint.name);\n          nameText.forEach(function (c) {\n            _this2._wUint8(c);\n          });\n        }\n\n        _this2._wUint8(encoded.separator);\n      });\n\n      if (_classPrivateFieldGet(this, _currentPos) != _classPrivateFieldGet(this, _bufferSize)) {\n        throw \"Failed to create the WebTrack buffer: final position and buffer size mismatch\";\n      }\n\n      return this;\n    }\n    /**\n     * Returns the output buffer if not null, otherwise the input buffer.\n     * @return Buffer or null/undefined if both the input and the output buffer are null/undefined.\n     */\n\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer() {\n      return _classPrivateFieldGet(this, _buffer);\n    }\n    /**\n     * Check if the first bytes of the input buffer match the file format.\n     * Returns false if the input buffer is null or undefined.\n     * @see loadWebTrack()\n     * @return True if match, false otherwise\n     */\n\n  }, {\n    key: \"_formatInfoPass\",\n    value: function _formatInfoPass() {\n      if (!_classPrivateFieldGet(this, _buffer)) {\n        return false;\n      }\n\n      var dec = new TextDecoder();\n      var fmtInput = new Uint8Array(_classPrivateFieldGet(this, _buffer), 0, this._fmtText().length);\n      return this._fmtText() == dec.decode(fmtInput);\n    }\n    /**\n     * Load a buffer containing the WebTrack.\n     * The file format and version must be as defined by this class.\n     * @param webtrackBytes The WebTrack buffer\n     * @return this\n     */\n\n  }, {\n    key: \"loadWebTrack\",\n    value: function loadWebTrack(webtrackBytes) {\n      if (!webtrackBytes) {\n        throw \"Failed to load WebTrack: bad input buffer\";\n      }\n\n      _classPrivateFieldSet(this, _buffer, webtrackBytes);\n\n      var typedBuffer = new Uint8Array(webtrackBytes);\n\n      _classPrivateFieldSet(this, _bufferSize, typedBuffer.length); // Format Information:\n\n\n      if (!this._formatInfoPass()) {\n        throw \"Failed to load WebTrack: bad file format\";\n      }\n\n      var enc = new TextEncoder();\n      var encoded = {\n        withEle: enc.encode(\"E\")[0],\n        withoutEle: enc.encode(\"F\")[0],\n        separator: enc.encode(\"\\n\")[0]\n      }; //$FlowIgnore[incompatible-call] error thrown earlier if the buffer is null\n\n      _classPrivateFieldSet(this, _view, new DataView(_classPrivateFieldGet(this, _buffer)));\n\n      _classPrivateFieldSet(this, _currentPos, this._fmtText().length);\n\n      var totalSegments = this._rUint8();\n\n      _classPrivateFieldSet(this, _totalWaypoints, this._rUint16());\n\n      _classPrivateFieldSet(this, _reformatedTracks, new Array(totalSegments));\n\n      _classPrivateFieldSet(this, _pointsWithEle, 0);\n\n      _classPrivateFieldSet(this, _pointsWithoutEle, 0); // Segment Headers:\n\n\n      for (var i = 0; i < totalSegments; i++) {\n        var currSegType = this._rUint8(),\n            points = this._rUint32(),\n            withEle = void 0;\n\n        switch (currSegType) {\n          case encoded.withEle:\n            withEle = true;\n\n            _classPrivateFieldSet(this, _pointsWithEle, _classPrivateFieldGet(this, _pointsWithEle) + points);\n\n            break;\n\n          case encoded.withoutEle:\n            withEle = false;\n\n            _classPrivateFieldSet(this, _pointsWithoutEle, _classPrivateFieldGet(this, _pointsWithoutEle) + points);\n\n            break;\n\n          default:\n            throw \"Failed to load WebTrack: bad segment type\";\n        }\n\n        _classPrivateFieldGet(this, _reformatedTracks)[i] = {\n          withEle: withEle,\n          points: new Array(points)\n        };\n      } // Track Information:\n\n\n      if (totalSegments) {\n        var length = this._rUint32();\n\n        if (this.someTracksWithEle()) {\n          _classPrivateFieldSet(this, _trackInfo, {\n            length: length,\n            min: this._rInt16(),\n            max: this._rInt16(),\n            gain: this._rUint32(),\n            loss: this._rUint32()\n          });\n        } else {\n          _classPrivateFieldSet(this, _trackInfo, {\n            length: length\n          });\n        }\n      } else {\n        _classPrivateFieldSet(this, _trackInfo, {});\n      } // Points from segments:\n\n\n      for (var _i = 0; _i < totalSegments; _i++) {\n        var totalPointsInSegment = _classPrivateFieldGet(this, _reformatedTracks)[_i].points.length;\n\n        var segWithEle = _classPrivateFieldGet(this, _reformatedTracks)[_i].withEle;\n\n        var prevPoint = null;\n\n        for (var p = 0; p < totalPointsInSegment; p++) {\n          if (prevPoint === null) {\n            prevPoint = [this._rInt32(), this._rInt32(), this._rUint16() * 10];\n          } else {\n            prevPoint = [this._rInt16() + prevPoint[0], this._rInt16() + prevPoint[1], this._rUint16() * 10];\n          }\n\n          if (segWithEle) {\n            prevPoint = [].concat(_toConsumableArray(prevPoint), [this._rInt16()]);\n          }\n\n          _classPrivateFieldGet(this, _reformatedTracks)[_i].points[p] = prevPoint;\n        }\n      } // Points from waypoints:\n\n\n      var dec = new TextDecoder();\n\n      _classPrivateFieldSet(this, _waypoints, new Array(_classPrivateFieldGet(this, _totalWaypoints)));\n\n      for (var _i2 = 0; _i2 < _classPrivateFieldGet(this, _totalWaypoints); _i2++) {\n        var wpt = {\n          lon: this._rInt32(),\n          lat: this._rInt32()\n        };\n\n        switch (this._rUint8()) {\n          case encoded.withEle:\n            wpt = _objectSpread(_objectSpread({}, wpt), {}, {\n              ele: this._rInt16()\n            });\n            break;\n\n          case encoded.withoutEle:\n            break;\n\n          default:\n            throw \"Failed to load WebTrack: bad waypoint type\";\n        }\n\n        var arr = [];\n\n        for (var c = this._rUint8(); c != encoded.separator; c = this._rUint8()) {\n          arr.push(c);\n        }\n\n        var bytes = new Uint8Array(arr);\n        var sym = dec.decode(bytes);\n        arr = [];\n\n        for (var _c = this._rUint8(); _c != encoded.separator; _c = this._rUint8()) {\n          arr.push(_c);\n        }\n\n        bytes = new Uint8Array(arr);\n        var name = dec.decode(bytes);\n        _classPrivateFieldGet(this, _waypoints)[_i2] = _objectSpread(_objectSpread({}, wpt), {}, {\n          sym: sym,\n          name: name\n        });\n      }\n\n      return this;\n    }\n  }]);\n\n  return WebTrack;\n}(); //$FlowIgnore[invalid-export] tested and working\n\n\nif (typeof module !== \"undefined\") {\n  //$FlowIgnore[invalid-export] tested and working\n  module.exports = WebTrack;\n}\n\n},{}]},{},[1])(1)\n});\n\n","// @flow\n\n/*!\n * MIT License\n *\n * Copyright (c) 2020 Clement\n * Copyright (c) 2018 Lucas Trebouet Voisin\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\ntype XMLDocument = any;\ntype Point = Array<any>;\ntype WayPoint = {\n    lat: number,\n    lon: number,\n    ele?: ?number,\n    sym?: string,\n    name?: string,\n    cumulDist?: number,\n};\ntype Segment = {\n    withEle: boolean,\n    points: Array<Point>,\n};\n\n/** Interface with the WebTrack file format. */\nclass WebTrack {\n    /** The WebTrack format name, constant. */\n    #formatName: string = \"webtrack-bin\";\n\n    /** The WebTrack format version, constant. */\n    #formatVersion: string = \"0.0.1\";\n\n    /** A list of segments in the WebTrack format. */\n    #reformatedTracks: Array<Segment> = [];\n\n    /** A list of waypoints in the WebTrack format. */\n    #waypoints: Array<WayPoint> = [];\n\n    /** Information about whole track (elevation statistics, etc.) */\n    #trackInfo: {\n        length: number,\n        min?: number,\n        max?: number,\n        gain?: number,\n        loss?: number,\n        trackPoints?: {\n            withEle: number,\n            withoutEle: number,\n        },\n    } = {};\n\n    /** Buffer used when loading a GPX string or a WebTrack buffer. */\n    #buffer: ?ArrayBuffer = null;\n\n    /** The size in bytes of the buffer. */\n    #bufferSize: number = 0;\n\n    /** The total amount of points containing elevation data. */\n    #pointsWithEle: number = 0;\n\n    /** The total amount of points not containing elevation data. */\n    #pointsWithoutEle: number = 0;\n\n    /** The current position in the buffer. */\n    #currentPos: number = 0;\n\n    /** The total amount of waypoints. */\n    #totalWaypoints: number = 0;\n\n    /** The DataView of the buffer. */\n    #view: DataView;\n\n    /**\n     * Load a GPX string and create a WebTrack buffer.\n     * @param gpxString The GPX string.\n     * @return this\n     */\n    loadGPX(gpxString: string): WebTrack {\n        this.#reformatedTracks = [];\n        this.#waypoints = [];\n        this.#pointsWithEle = 0;\n        this.#pointsWithoutEle = 0;\n        let domParser = new window.DOMParser();\n        let xmlSource: XMLDocument = domParser.parseFromString(\n            gpxString.trim(),\n            \"text/xml\"\n        );\n\n        let trks = [].slice.call(xmlSource.querySelectorAll(\"trk\"));\n        let prevPt = {};\n        let min = Number.POSITIVE_INFINITY,\n            max = Number.NEGATIVE_INFINITY,\n            gain = 0,\n            loss = 0;\n\n        trks.forEach((trk) => {\n            // loop over <trk/>\n            let trackpoints = [];\n            let trkpts = [].slice.call(trk.querySelectorAll(\"trkpt\"));\n\n            let segment: Segment = {};\n            let isFirst = true;\n            let prevEle = null;\n\n            trkpts.forEach((trkpt) => {\n                // loop over <trkpt/>\n                let pt: WayPoint = {};\n                pt.lat = parseFloat(trkpt.getAttribute(\"lat\"));\n                pt.lon = parseFloat(trkpt.getAttribute(\"lon\"));\n                pt.ele =\n                    parseFloat(this._getElementValue(trkpt, \"ele\")) || null;\n                if (\n                    Object.keys(prevPt).length === 0 &&\n                    prevPt.constructor === Object\n                ) {\n                    pt.cumulDist = 0.0;\n                } else {\n                    pt.cumulDist =\n                        //$FlowIgnore[unsafe-addition] operation with satisfying conditions\n                        prevPt.cumulDist + this.distanceBetween(prevPt, pt);\n                }\n                prevPt = { ...pt };\n                trackpoints.push(pt);\n                let webPt = this.gpsToWeb(pt.lon, pt.lat);\n\n                if (isFirst) {\n                    if (pt.ele === null) {\n                        segment.withEle = false;\n                        segment.points = [[...webPt, pt.cumulDist]];\n                    } else {\n                        segment.withEle = true;\n                        segment.points = [[...webPt, pt.cumulDist, pt.ele]];\n                    }\n                    isFirst = false;\n                } else {\n                    if (pt.ele === null) {\n                        if (segment.withEle) {\n                            // split\n                            this.#pointsWithEle += segment.points.length;\n                            this.#reformatedTracks.push(segment);\n                            segment = {}; // fresh segment\n                            segment.withEle = false;\n                            segment.points = [[...webPt, pt.cumulDist]];\n                        } else {\n                            segment.points.push([...webPt, pt.cumulDist]);\n                        }\n                    } else {\n                        if (!segment.withEle) {\n                            this.#pointsWithoutEle += segment.points.length;\n                            this.#reformatedTracks.push(segment);\n                            segment = {};\n                            segment.withEle = true;\n                            segment.points = [[...webPt, pt.cumulDist, pt.ele]];\n                        } else {\n                            segment.points.push([\n                                ...webPt,\n                                pt.cumulDist,\n                                pt.ele,\n                            ]);\n                        }\n                    }\n                }\n\n                if (pt.ele !== null) {\n                    if (prevEle !== null) {\n                        //$FlowIgnore[unsafe-addition]\n                        var diff = pt.ele - prevEle;\n                        if (diff < 0) {\n                            loss -= diff;\n                        } else if (diff > 0) {\n                            gain += diff;\n                        }\n                    }\n                    //$FlowIgnore[invalid-compare]\n                    if (min > pt.ele) {\n                        min = pt.ele;\n                    }\n                    //$FlowIgnore[invalid-compare]\n                    if (max < pt.ele) {\n                        max = pt.ele;\n                    }\n                    prevEle = pt.ele;\n                }\n            });\n\n            if (segment) {\n                if (segment.withEle) {\n                    this.#pointsWithEle += segment.points.length;\n                } else {\n                    this.#pointsWithoutEle += segment.points.length;\n                }\n                this.#reformatedTracks.push(segment);\n            }\n\n            if (this.#reformatedTracks.length > 255) {\n                throw \"Failed to load the GPX string: exceeding 255 segments\";\n            }\n        });\n\n        this.#trackInfo = {\n            length: this.getTrackLength(),\n            min: min,\n            max: max,\n            gain: gain,\n            loss: loss,\n        };\n\n        var wpts = [].slice.call(xmlSource.querySelectorAll(\"wpt\"));\n\n        wpts.forEach((wpt) => {\n            // loop over <wpt/>\n            let time = this._getElementValue(wpt, \"time\");\n            let coords = this.gpsToWeb(\n                parseFloat(wpt.getAttribute(\"lon\")),\n                parseFloat(wpt.getAttribute(\"lat\"))\n            );\n\n            this.#waypoints.push({\n                name: this._getElementValue(wpt, \"name\") || null,\n                sym: this._getElementValue(wpt, \"sym\") || null,\n                lon: coords[0],\n                lat: coords[1],\n                ele: parseFloat(this._getElementValue(wpt, \"ele\")) || null,\n                time: time == null ? null : new Date(time),\n            });\n        });\n\n        this.#totalWaypoints = this.#waypoints.length;\n\n        this.#bufferSize =\n            this._fmtArraySize() +\n            this._trksArraySize() +\n            this._wptsArraySize();\n\n        this.createBuffer();\n        return this;\n    }\n\n    /**\n     * Get value from a XML DOM element\n     *\n     * @param  {Element} parent - Parent DOM Element\n     * @param  {string} needle - Name of the searched element\n     *\n     * @return The element value\n     */\n    _getElementValue(parent: Element, needle: string): any {\n        let elem = parent.querySelector(needle);\n        if (elem != null) {\n            return elem.innerHTML != undefined\n                ? elem.innerHTML\n                : //$FlowIgnore[prop-missing]\n                  elem.childNodes[0].data;\n        }\n        return elem;\n    }\n\n    /**\n     * Compute the dstance between two points.\n     *\n     * @param  {WayPoint} wpt1 - A geographic point with lat and lon properties\n     * @param  {WayPoint} wpt2 - A geographic point with lat and lon properties\n     *\n     * @returns {float} The distance between the two points\n     */\n    distanceBetween(wpt1: WayPoint, wpt2: WayPoint): number {\n        let latlng1 = {};\n        latlng1.lat = wpt1.lat;\n        latlng1.lon = wpt1.lon;\n        let latlng2 = {};\n        latlng2.lat = wpt2.lat;\n        latlng2.lon = wpt2.lon;\n        var rad = Math.PI / 180,\n            lat1 = latlng1.lat * rad,\n            lat2 = latlng2.lat * rad,\n            sinDLat = Math.sin(((latlng2.lat - latlng1.lat) * rad) / 2),\n            sinDLon = Math.sin(((latlng2.lon - latlng1.lon) * rad) / 2),\n            a =\n                sinDLat * sinDLat +\n                Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,\n            c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return 6371008 * c;\n    }\n\n    /**\n     * Returns the first characters that should be in the WebTrack file.\n     * Example: 'webtrack-bin:0.1.2:'\n     * @return ASCII characters.\n     */\n    _fmtText(): string {\n        return `${this.#formatName}:${this.#formatVersion}:`;\n    }\n\n    /**\n     * Returns the length in bytes of the \"Format Information\" section.\n     * @return Number of bytes.\n     */\n    _fmtArraySize(): number {\n        return this._fmtText().length + 3;\n    }\n\n    /**\n     * Returns the length in bytes of the \"Segment Headers\",\n     * plus the \"Track Information\", plus the \"Segment\" sections.\n     * @return Number of bytes.\n     */\n    _trksArraySize(): number {\n        const totalSegments = this.#reformatedTracks.length;\n        let trksArraySize = 0;\n\n        if (totalSegments > 0) {\n            // segment headers:\n            trksArraySize += totalSegments * 5;\n            // tracks info (length):\n            trksArraySize += 4;\n            if (this.#pointsWithEle > 0) {\n                // tracks info (ele min/max/gain/loss):\n                trksArraySize += 12;\n            }\n\n            trksArraySize +=\n                totalSegments * 4 +\n                this.#pointsWithoutEle * 6 +\n                this.#pointsWithEle * 8;\n        }\n\n        return trksArraySize;\n    }\n\n    /**\n     * Returns the length in bytes of the \"Waypoints\" section.\n     * @return Number of bytes.\n     */\n    _wptsArraySize(): number {\n        let wptsArraySize = 0;\n\n        this.#waypoints.forEach((waypoint) => {\n            wptsArraySize +=\n                11 +\n                (waypoint.ele ? 2 : 0) +\n                (waypoint.sym ? waypoint.sym.length : 0) +\n                (waypoint.name ? waypoint.name.length : 0);\n        });\n\n        return wptsArraySize;\n    }\n\n    /**\n     * Returns true if there is at least one point with elevation data.\n     * @return False if there isn't a single point with elevation, true otherwise.\n     */\n    someTracksWithEle(): boolean {\n        return this.#pointsWithEle > 0;\n    }\n\n    /**\n     * Returns the size of the buffer.\n     * @return Number of bytes.\n     */\n    getBufferSize(): number {\n        return this.#bufferSize;\n    }\n\n    /**\n     * Append a uint8 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n    _wUint8(data: number) {\n        this.#view.setUint8(this.#currentPos++, data);\n    }\n\n    /**\n     * Read a uint8 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The byte from the buffer.\n     */\n    _rUint8(): number {\n        return this.#view.getUint8(this.#currentPos++);\n    }\n\n    /**\n     * Append a uint16 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n    _wUint16(data: number) {\n        this.#view.setUint16(this.#currentPos, data, false);\n        this.#currentPos += 2;\n    }\n\n    /**\n     * Read a uint16 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The bytes from the buffer.\n     */\n    _rUint16(): number {\n        let pos = this.#currentPos;\n        this.#currentPos += 2;\n        return this.#view.getUint16(pos, false);\n    }\n\n    /**\n     * Append a int16 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n    _wInt16(data: number) {\n        this.#view.setInt16(this.#currentPos, data, false);\n        this.#currentPos += 2;\n    }\n\n    /**\n     * Read a int16 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The bytes from the buffer.\n     */\n    _rInt16(): number {\n        let pos = this.#currentPos;\n        this.#currentPos += 2;\n        return this.#view.getInt16(pos, false);\n    }\n\n    /**\n     * Append a uint32 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n    _wUint32(data: number) {\n        this.#view.setUint32(this.#currentPos, data, false);\n        this.#currentPos += 4;\n    }\n\n    /**\n     * Read a uint32 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The bytes from the buffer.\n     */\n    _rUint32(): number {\n        let pos = this.#currentPos;\n        this.#currentPos += 4;\n        return this.#view.getUint32(pos, false);\n    }\n\n    /**\n     * Append a int32 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n    _wInt32(data: number) {\n        this.#view.setInt32(this.#currentPos, data, false);\n        this.#currentPos += 4;\n    }\n\n    /**\n     * Read a int32 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The bytes from the buffer.\n     */\n    _rInt32(): number {\n        let pos = this.#currentPos;\n        this.#currentPos += 4;\n        return this.#view.getInt32(pos, false);\n    }\n\n    /**\n     * Projection of a GPS point (EPSG:4326) into the Web Mercator (EPSG:3857).\n     * Formula based on:\n     * Title: Implementation Practice Web Mercator Map Projection\n     * Reference: NGA.SIG.0011_1.0.0_WEBMERC, 2014-02-18\n     * Author: National Geospatial Intelligence Agency (NGA)\n     * @param lon GPS longitude\n     * @param lat GPS latitude\n     * @return Web Mercator coordinates [easting, northing]\n     */\n    gpsToWeb(lon: number, lat: number): Point {\n        const rad = Math.PI / 180;\n        // ellipsoid semi-major axis [WSG 84 = 6378137m]:\n        const a = 6378137;\n        // no parseInt to reduce drift when substracting coordinates:\n        return [\n            // easting coordinate in the Web Mercator:\n            lon * a * rad,\n            // northing coordinate in the Web Mercator:\n            a * Math.atanh(Math.sin(lat * rad)),\n        ];\n    }\n\n    /**\n     * Returns essential information about the track.\n     */\n    getTrackInfo(): {} {\n        return {\n            ...this.#trackInfo,\n            trackPoints: {\n                withEle: this.#pointsWithEle,\n                withoutEle: this.#pointsWithoutEle,\n            },\n        };\n    }\n\n    /**\n     * Returns an array of segments in the WebTrack format.\n     */\n    getTrack(): Array<Segment> {\n        return this.#reformatedTracks;\n    }\n\n    /**\n     * Returns an array of waypoints in the WebTrack format.\n     */\n    getWaypoints(): Array<WayPoint> {\n        return this.#waypoints;\n    }\n\n    /**\n     * Returns the length of the whole track.\n     */\n    getTrackLength(): number {\n        const lastSegment = this.#reformatedTracks[\n            this.#reformatedTracks.length - 1\n        ].points;\n        return lastSegment[lastSegment.length - 1][2];\n    }\n\n    /**\n     * Create a WebTrack buffer with the data fetched from the GPX string.\n     * @return A WebTrack buffer ready to be stored.\n     */\n    createBuffer(): WebTrack {\n        if (this.#bufferSize == 0) {\n            throw \"Failed to create the WebTrack buffer: empty buffer\";\n        }\n        this.#buffer = new ArrayBuffer(this.#bufferSize);\n        this.#view = new DataView(this.#buffer);\n        const enc = new TextEncoder();\n        const encoded = {\n            withEle: enc.encode(\"E\")[0],\n            withoutEle: enc.encode(\"F\")[0],\n            separator: enc.encode(\"\\n\")[0],\n        };\n\n        // Format Information:\n\n        const fmtText = enc.encode(this._fmtText());\n        this.#currentPos = 0;\n\n        fmtText.forEach((c) => {\n            this._wUint8(c);\n        });\n        const totalSegments = this.#reformatedTracks.length;\n        if (totalSegments > 255) {\n            throw \"Failed to create the WebTrack buffer: too many segments\";\n        }\n        this._wUint8(totalSegments);\n        if (this.#totalWaypoints > 65535) {\n            throw \"Failed to create the WebTrack buffer: too many waypoints\";\n        }\n        this._wUint16(this.#totalWaypoints);\n\n        // Segment Headers:\n\n        this.#reformatedTracks.forEach((segment) => {\n            let c = segment.withEle ? encoded.withEle : encoded.withoutEle;\n            this._wUint8(c);\n            // Number of points written in big-endian:\n            this._wUint32(segment.points.length);\n        });\n\n        // Track Information:\n\n        this._wUint32(Math.round(this.#trackInfo.length));\n        if (this.someTracksWithEle()) {\n            //$FlowIgnore[incompatible-call] condition satisfied\n            this._wInt16(Math.round(this.#trackInfo.min));\n            //$FlowIgnore[incompatible-call] condition satisfied\n            this._wInt16(Math.round(this.#trackInfo.max));\n            //$FlowIgnore[incompatible-call] condition satisfied\n            this._wUint32(Math.round(this.#trackInfo.gain));\n            //$FlowIgnore[incompatible-call] condition satisfied\n            this._wUint32(Math.round(this.#trackInfo.loss));\n        }\n\n        // Points from segments:\n\n        let errorDeltaX = 0,\n            errorDeltaY = 0;\n        this.#reformatedTracks.forEach((segment) => {\n            let prevPoint = null;\n            segment.points.forEach((point) => {\n                if (prevPoint === null) {\n                    this._wInt32(Math.round(point[0]));\n                    this._wInt32(Math.round(point[1]));\n\n                    // cumulated distance:\n                    this._wUint16(Math.round(point[2] / 10));\n\n                    errorDeltaX = 0;\n                    errorDeltaY = 0;\n                } else {\n                    // offset with drift correction\n                    const deltaX = point[0] - prevPoint[0] + errorDeltaX,\n                        deltaY = point[1] - prevPoint[1] + errorDeltaY;\n\n                    const minDelta = -32768,\n                        maxDelta = 32767;\n                    if (\n                        deltaX > maxDelta ||\n                        deltaX < minDelta ||\n                        deltaY > maxDelta ||\n                        deltaY < minDelta\n                    ) {\n                        throw \"Failed to create the WebTrack buffer: offset out or range\";\n                    }\n                    this._wInt16(Math.round(deltaX));\n                    this._wInt16(Math.round(deltaY));\n\n                    // rounding positions create a drift corrected on the next point(s)\n                    errorDeltaX = deltaX - Math.round(deltaX);\n                    errorDeltaY = deltaY - Math.round(deltaY);\n\n                    this._wUint16(Math.round(point[2] / 10));\n                }\n                prevPoint = point;\n\n                if (segment.withEle) {\n                    this._wInt16(Math.round(point[3]));\n                }\n            });\n        });\n\n        // Points from waypoints:\n\n        this.#waypoints.forEach((waypoint) => {\n            this._wInt32(Math.round(waypoint.lon));\n            this._wInt32(Math.round(waypoint.lat));\n            this._wUint8(waypoint.ele ? encoded.withEle : encoded.withoutEle);\n            if (waypoint.ele) {\n                this._wInt16(Math.round(waypoint.ele));\n            }\n            if (waypoint.sym) {\n                const symText = enc.encode(waypoint.sym);\n                symText.forEach((c) => {\n                    this._wUint8(c);\n                });\n            }\n            this._wUint8(encoded.separator);\n            if (waypoint.name) {\n                const nameText = enc.encode(waypoint.name);\n                nameText.forEach((c) => {\n                    this._wUint8(c);\n                });\n            }\n            this._wUint8(encoded.separator);\n        });\n\n        if (this.#currentPos != this.#bufferSize) {\n            throw \"Failed to create the WebTrack buffer: final position and buffer size mismatch\";\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns the output buffer if not null, otherwise the input buffer.\n     * @return Buffer or null/undefined if both the input and the output buffer are null/undefined.\n     */\n    getBuffer(): ?ArrayBuffer {\n        return this.#buffer;\n    }\n\n    /**\n     * Check if the first bytes of the input buffer match the file format.\n     * Returns false if the input buffer is null or undefined.\n     * @see loadWebTrack()\n     * @return True if match, false otherwise\n     */\n    _formatInfoPass(): boolean {\n        if (!this.#buffer) {\n            return false;\n        }\n        const dec = new TextDecoder();\n        const fmtInput = new Uint8Array(\n            this.#buffer,\n            0,\n            this._fmtText().length\n        );\n        return this._fmtText() == dec.decode(fmtInput);\n    }\n\n    /**\n     * Load a buffer containing the WebTrack.\n     * The file format and version must be as defined by this class.\n     * @param webtrackBytes The WebTrack buffer\n     * @return this\n     */\n    loadWebTrack(webtrackBytes: ArrayBuffer): WebTrack {\n        if (!webtrackBytes) {\n            throw \"Failed to load WebTrack: bad input buffer\";\n        }\n        this.#buffer = webtrackBytes;\n        let typedBuffer = new Uint8Array(webtrackBytes);\n        this.#bufferSize = typedBuffer.length;\n\n        // Format Information:\n\n        if (!this._formatInfoPass()) {\n            throw \"Failed to load WebTrack: bad file format\";\n        }\n\n        const enc = new TextEncoder();\n        const encoded = {\n            withEle: enc.encode(\"E\")[0],\n            withoutEle: enc.encode(\"F\")[0],\n            separator: enc.encode(\"\\n\")[0],\n        };\n        //$FlowIgnore[incompatible-call] error thrown earlier if the buffer is null\n        this.#view = new DataView(this.#buffer);\n        this.#currentPos = this._fmtText().length;\n        const totalSegments = this._rUint8();\n        this.#totalWaypoints = this._rUint16();\n        this.#reformatedTracks = new Array(totalSegments);\n        this.#pointsWithEle = 0;\n        this.#pointsWithoutEle = 0;\n\n        // Segment Headers:\n\n        for (let i = 0; i < totalSegments; i++) {\n            let currSegType = this._rUint8(),\n                points = this._rUint32(),\n                withEle;\n            switch (currSegType) {\n                case encoded.withEle:\n                    withEle = true;\n                    this.#pointsWithEle += points;\n                    break;\n                case encoded.withoutEle:\n                    withEle = false;\n                    this.#pointsWithoutEle += points;\n                    break;\n                default:\n                    throw \"Failed to load WebTrack: bad segment type\";\n            }\n            this.#reformatedTracks[i] = {\n                withEle: withEle,\n                points: new Array(points),\n            };\n        }\n\n        // Track Information:\n\n        if (totalSegments) {\n            let length = this._rUint32();\n            if (this.someTracksWithEle()) {\n                this.#trackInfo = {\n                    length: length,\n                    min: this._rInt16(),\n                    max: this._rInt16(),\n                    gain: this._rUint32(),\n                    loss: this._rUint32(),\n                };\n            } else {\n                this.#trackInfo = {\n                    length: length,\n                };\n            }\n        } else {\n            this.#trackInfo = {};\n        }\n\n        // Points from segments:\n\n        for (let i = 0; i < totalSegments; i++) {\n            const totalPointsInSegment = this.#reformatedTracks[i].points\n                .length;\n            const segWithEle = this.#reformatedTracks[i].withEle;\n            let prevPoint = null;\n\n            for (let p = 0; p < totalPointsInSegment; p++) {\n                if (prevPoint === null) {\n                    prevPoint = [\n                        this._rInt32(),\n                        this._rInt32(),\n                        this._rUint16() * 10,\n                    ];\n                } else {\n                    prevPoint = [\n                        this._rInt16() + prevPoint[0],\n                        this._rInt16() + prevPoint[1],\n                        this._rUint16() * 10,\n                    ];\n                }\n                if (segWithEle) {\n                    prevPoint = [...prevPoint, this._rInt16()];\n                }\n                this.#reformatedTracks[i].points[p] = prevPoint;\n            }\n        }\n\n        // Points from waypoints:\n\n        const dec = new TextDecoder();\n        this.#waypoints = new Array(this.#totalWaypoints);\n        for (let i = 0; i < this.#totalWaypoints; i++) {\n            let wpt = {\n                lon: this._rInt32(),\n                lat: this._rInt32(),\n            };\n\n            switch (this._rUint8()) {\n                case encoded.withEle:\n                    wpt = { ...wpt, ele: this._rInt16() };\n                    break;\n                case encoded.withoutEle:\n                    break;\n                default:\n                    throw \"Failed to load WebTrack: bad waypoint type\";\n            }\n\n            let arr = [];\n            for (\n                let c = this._rUint8();\n                c != encoded.separator;\n                c = this._rUint8()\n            ) {\n                arr.push(c);\n            }\n            let bytes = new Uint8Array(arr);\n            let sym = dec.decode(bytes);\n\n            arr = [];\n            for (\n                let c = this._rUint8();\n                c != encoded.separator;\n                c = this._rUint8()\n            ) {\n                arr.push(c);\n            }\n            bytes = new Uint8Array(arr);\n            let name = dec.decode(bytes);\n\n            this.#waypoints[i] = { ...wpt, sym: sym, name: name };\n        }\n\n        return this;\n    }\n}\n\n//$FlowIgnore[invalid-export] tested and working\nif (typeof module !== \"undefined\") {\n    //$FlowIgnore[invalid-export] tested and working\n    module.exports = WebTrack;\n}\n"]}