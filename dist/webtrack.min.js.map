{"version":3,"sources":["node_modules/browser-pack/_prelude.js","webtrack.min.js","modules/webtrack.js"],"names":["f","exports","_typeof2","module","define","amd","window","global","self","this","WebTrack","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","_typeof","obj","Symbol","iterator","constructor","prototype","_toConsumableArray","arr","g","Array","isArray","_arrayLikeToArray","_arrayWithoutHoles","iter","Object","from","minLen","toString","slice","name","test","_unsupportedIterableToArray","TypeError","_nonIterableSpread","len","arr2","ownKeys","object","enumerableOnly","symbols","keys","getOwnPropertySymbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","arguments","source","forEach","key","value","defineProperty","configurable","writable","getOwnPropertyDescriptors","defineProperties","props","descriptor","_classPrivateFieldGet","receiver","privateMap","get","_classPrivateFieldSet","set","_formatName","WeakMap","_formatVersion","_reformatedTracks","_buffer","_bufferSize","_pointsWithEle","_pointsWithoutEle","_totalWaypoints","_view","instance","Constructor","_classCallCheck","_waypoints","_defineProperty","protoProps","staticProps","gpxString","_this","xmlSource","DOMParser","parseFromString","trim","trks","querySelectorAll","prevPt","min","Number","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","gain","loss","trk","trackpoints","trkpts","segment","isFirst","prevEle","trkpt","pt","lat","parseFloat","getAttribute","lon","ele","_getElementValue","cumulDist","distanceBetween","diff","webPt","gpsToWeb","withEle","points","concat","_trackInfo","getTrackLength","wpt","time","coords","Date","_fmtArraySize","_trksArraySize","_wptsArraySize","createBuffer","parent","needle","elem","querySelector","undefined","innerHTML","childNodes","data","wpt1","wpt2","latlng1","latlng2","rad","Math","PI","lat1","lat2","sinDLat","sin","sinDLon","cos","atan2","sqrt","_fmtText","totalSegments","trksArraySize","wptsArraySize","waypoint","_this$currentPos","setUint8","_currentPos","_this$currentPos2","getUint8","setUint16","pos","getUint16","setInt16","getInt16","setUint32","getUint32","setInt32","getInt32","atanh","trackPoints","withoutEle","lastSegment","_this2","ArrayBuffer","DataView","enc","TextEncoder","encoded","encode","separator","fmtText","_wUint8","_wUint16","_wUint32","round","someTracksWithEle","_wInt16","prevPoint","point","_wInt32","deltaX","deltaY","dec","TextDecoder","fmtInput","Uint8Array","decode","webtrackBytes","typedBuffer","_formatInfoPass","_rUint8","_rUint16","currSegType","_rUint32","_rInt16","_i","totalPointsInSegment","segWithEle","_rInt32","_i2","bytes","_c","_defineProperties"],"mappings":"iQAAA,SAAAA,GAAA,YAAA,oBAAAC,QAAA,YAAAC,SAAAD,WAAA,oBAAAE,OAAAA,OAAAF,QAAAD,IAAA,mBAAAI,QAAAA,OAAAC,IAAAD,OAAA,GAAAJ,IAAA,oBAAAM,OAAAA,OAAA,oBAAAC,OAAAA,OAAA,oBAAAC,KAAAA,KAAAC,MAAAC,SAAAV,IAAA,CAAA,WAAA,OAAA,SAAAW,EAAAC,EAAAC,EAAAC,GAAA,SAAAC,EAAAC,EAAAhB,GAAA,IAAAa,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,IAAAC,EAAA,mBAAAC,SAAAA,QAAA,IAAAlB,GAAAiB,EAAA,OAAAA,EAAAD,GAAA,GAAA,GAAAG,EAAA,OAAAA,EAAAH,GAAA,GAAA,IAAAI,EAAA,IAAAC,MAAA,uBAAAL,EAAA,KAAA,MAAAI,EAAAE,KAAA,mBAAAF,EAAA,IAAAG,EAAAV,EAAAG,GAAA,CAAAf,QAAA,IAAAW,EAAAI,GAAA,GAAAQ,KAAAD,EAAAtB,QAAA,SAAAU,GAAA,OAAAI,EAAAH,EAAAI,GAAA,GAAAL,IAAAA,IAAAY,EAAAA,EAAAtB,QAAAU,EAAAC,EAAAC,EAAAC,GAAA,OAAAD,EAAAG,GAAAf,QAAA,IAAA,IAAAkB,EAAA,mBAAAD,SAAAA,QAAAF,EAAA,EAAAA,EAAAF,EAAAW,OAAAT,IAAAD,EAAAD,EAAAE,IAAA,OAAAD,EAAA,CAAA,CAAAW,EAAA,CAAA,SAAAR,EAAAf,EAAAF,GCGA,SAAS0B,EAAQC,GAAmV,OAAtOD,EAArD,mBAAXE,QAAoD,iBAApBA,OAAOC,SAAmC,SAAiBF,GAAO,cAAcA,GAA2B,SAAiBA,GAAO,OAAOA,GAAyB,mBAAXC,QAAyBD,EAAIG,cAAgBF,QAAUD,IAAQC,OAAOG,UAAY,gBAAkBJ,IAAyBA,GDHnX,SAAAK,EAAAC,GAAA,OAAAC,SAAAD,GAAA,GAAAE,MAAAC,QAAAH,GAAA,OAAAI,EAAAJ,GAAAK,CAAAL,ICWA,SAA0BM,GAAQ,GAAsB,oBAAXX,QAA0BA,OAAOC,YAAYW,OAAOD,GAAO,OAAOJ,MAAMM,KAAKF,GDX1HvC,CAAAiC,IAAA,SAAAnB,EAAA4B,GAAA,IAAA5B,EAAA,OAAA,GAAA,iBAAAA,EAAA,OAAAuB,EAAAvB,EAAA4B,GAAA,IAAA9B,EAAA4B,OAAAT,UAAAY,SAAApB,KAAAT,GAAA8B,MAAA,GAAA,GAAA,WAAAhC,GAAAE,EAAAgB,cAAAlB,EAAAE,EAAAgB,YAAAe,MAAA,GAAA,QAAAjC,GAAA,QAAAA,EAAA,OAAAuB,MAAAM,KAAA3B,GAAA,GAAA,cAAAF,GAAA,2CAAAkC,KAAAlC,GAAA,OAAAyB,EAAAvB,EAAA4B,GAAAK,CAAAd,IAAA,WAAA,MAAA,IAAAe,UAAA5C,wIAAA6C,GAAAf,SAAAG,EAAAJ,EAAAiB,IAAA,MAAAA,GAAAA,EAAAjB,EAAAT,UAAA0B,EAAAjB,EAAAT,QAAA,IAAA,IAAAT,EAAA,EAAAoC,EAAA,IAAAhB,MAAAe,GAAAnC,EAAAmC,EAAAnC,IAAAoC,EAAApC,GAAAkB,EAAAlB,GAAA,OAAAoC,EAAAjB,SAAAkB,EAAAC,EAAAC,GAAA,IAAAC,EAAAC,EAAAhB,OAAAgB,KAAAH,GAAA,OAAAb,OAAAiB,wBAAAF,EAAAf,OAAAiB,sBAAAJ,GAAAC,IAAAC,EAAAA,EAAAG,OAAA,SAAAC,GAAA,OAAAnB,OAAAoB,yBAAAP,EAAAM,GAAAE,cAAAL,EAAAM,KAAAC,MAAAP,EAAAD,IAAAC,EAAAtB,SAAA8B,EAAAC,GAAA,IAAA,IAAAlD,EAAA,EAAAA,EAAAmD,UAAA1C,OAAAT,IAAA,CAAA,IAAAoD,EAAA,MAAAD,UAAAnD,GAAAmD,UAAAnD,GAAA,GAAAA,EAAA,EAAAqC,EAAAZ,OAAA2B,IAAA,GAAAC,QAAA,SAAAC,GCqBA,IAAyB1C,EAAK0C,EAAKC,EAAV3C,EDrBzBsC,ECqBmCK,EDrBnCH,ECqB8BE,EDrB9BA,GCqBgDA,KAAO1C,EAAOa,OAAO+B,eAAe5C,EAAK0C,EAAK,CAAEC,MAAOA,EAAOT,YAAY,EAAMW,cAAc,EAAMC,UAAU,IAAkB9C,EAAI0C,GAAOC,IDrB3L9B,OAAAkC,0BAAAlC,OAAAmC,iBAAAV,EAAAzB,OAAAkC,0BAAAP,IAAAf,EAAAZ,OAAA2B,IAAAC,QAAA,SAAAC,GAAA7B,OAAA+B,eAAAN,EAAAI,EAAA7B,OAAAoB,yBAAAO,EAAAE,MAAA,OAAAJ,EAAA,SAAA9D,EAAAH,EAAA4E,GAAA,IAAA,IAAA7D,EAAA,EAAAA,EAAA6D,EAAApD,OAAAT,IAAA,CAAA,IAAA8D,EAAAD,EAAA7D,GAAA8D,EAAAhB,WAAAgB,EAAAhB,aAAA,EAAAgB,EAAAL,cAAA,EAAA,UAAAK,IAAAA,EAAAJ,UAAA,GAAAjC,OAAA+B,eAAAN,EAAAY,EAAAR,IAAAQ,IAAA,SAAAC,EAAAC,EAAAC,GAAA,IAAAH,EAAAG,EAAAC,IAAAF,GAAA,IAAAF,EAAA,MAAA,IAAA7B,UAAA,kDAAA,OAAA6B,EAAAI,IAAAJ,EAAAI,IAAA1D,KAAAwD,GAAAF,EAAAP,MAAA,SAAAY,EAAAH,EAAA9D,EAAAA,GAAA,IAAA4D,EAAAG,EAAAC,IAAAF,GAAA,IAAAF,EAAA,MAAA,IAAA7B,UAAA,kDAAA,GAAA6B,EAAAM,IAAAN,EAAAM,IAAA5D,KAAAwD,EAAAT,OAAA,CAAA,IAAAO,EAAAJ,SAAA,MAAA,IAAAzB,UAAA,4CAAA6B,EAAAP,MAAAA,EAAA,OAAAA,EAAA,IAAAc,EAAA,IAAAC,QAAAC,EAAAjE,IAAAgE,QCqCIE,EAAoB,IAAIF,QDrC5BrF,EAAAA,IAAAqF,QAAA1E,EAAA,IAAAY,QAAAiE,EAAA,IAAAH,QAAAI,EAAA,IAAAJ,QAAAK,EAAA1F,IAAAA,QCiDI2F,EAAoB,IAAIN,QDjD5BvE,EAAA,IAAAuE,QCqDIO,EAAkB,IAAIP,QDrD1BQ,EAAA,IAAAR,QE2CM5E,EDpC8C,WAA0I,SAAAA,KDP9L,SAAAqF,EAAAC,GAAA,KAAAD,aAAAC,GAAA,MAAA,IAAA/C,UAAA,qCCqFIgD,CAAgBxF,KAAMC,GA5EwB2E,EAAQD,IAAA3E,KAAA,CAAQiE,UAAI,EAA4DH,MCoCxG,iBDpCmRgB,EAAUH,IAAA3E,KAAN,CAA+GiE,UAAA,EAqF1ZH,MC9CuB,UDrCqGiB,EAAAJ,IAAA3E,KAAA,CAuF5HiE,UAAU,EArFhBH,MCsCwC,KDmDpC2B,EAAWd,IAAI3E,KAAM,CAvFzBiE,UAASpC,EAA8BiC,MCuCL,KDvCmHnB,EAAKpC,IAALP,KAAa,CAAMiE,UAAA,EA8FlKH,MC1CE,KD6CJkB,EAAQL,IAAI3E,KAAM,CA/FtBiE,UAASrB,EAAkCkB,MCqDf,ODrDmFmB,EAAIlC,IAAAA,KAAUf,CAAsCiC,UAAInB,EAA0DgB,MCwDvM,IDxD4SoB,EAAAP,IAAA3E,KAAA,CA0GhUiE,UAAU,EA1GuTH,MC2D1S,IDzD7BqB,EAAS3B,IAAAA,KAAcC,CAAUQ,UAAK,EAAwCH,MC4D9C,ID5DkHlB,EAAAA,IAAQZ,KAAM,CAAyC0D,UAAAA,EAA4C5B,MC+D3N,ID/DyVsB,EAAMT,IAAA3E,KAAA,CAAE4C,UAAAA,EAAiDZ,MCkE9Y,IDlEueqD,EAAAV,IAAA3E,KAAA,CA4H/fiE,UAAU,EA5HsfH,WAAA,IDnBtgB,IAAAyB,EAAAI,EAAAC,ECk+BE,ODl+BFL,ECqBmDtF,GDrBnD0F,ECqB4D,CAAA,CAAE3D,IAAAA,UAAkHb,MAAAA,SC0EpK0E,GAA6B,IAAAC,EAAA9F,KACjC0E,EAAA1E,KAAA+E,EAAyB,IACzBL,EAAA1E,KAAAyF,EAAkB,IAClBf,EAAA1E,KAAAkF,EAAsB,GACtBR,EAAA1E,KAAAmF,EAAyB,GACzB,IACIY,GADY,IAAIlG,OAAOmG,WACYC,gBACnCJ,EAAUK,OACV,YAGAC,EAAO,GAAG/D,MAAMrB,KAAKgF,EAAUK,iBAAiB,QAChDC,EAAS,GACTC,EAAMC,OAAOC,kBACbC,EAAMF,OAAOG,kBACbC,EAAO,EACPC,EAAO,EA8IX,OA5IAT,EAAKvC,QAAQ,SAACiD,GAEV,IAAIC,EAAc,GACdC,EAAS,GAAG3E,MAAMrB,KAAK8F,EAAIT,iBAAiB,UAE5CY,EAAmB,GACnBC,GAAU,EACVC,EAAU,KA4Fd,GA1FAH,EAAOnD,QAAQ,SAACuD,GAEZ,IAAIC,EAAe,GACnBA,EAAGC,IAAMC,WAAWH,EAAMI,aAAa,QACvCH,EAAGI,IAAMF,WAAWH,EAAMI,aAAa,QACvCH,EAAGK,IACCH,WAAWxB,EAAK4B,iBAAiBP,EAAO,SAAW,KAEpB,IAA/BnF,OAAOgB,KAAKqD,GAAQrF,QACpBqF,EAAO/E,cAAgBU,OAEvBoF,EAAGO,UAAY,EAEfP,EAAGO,UAECtB,EAAOsB,UAAY7B,EAAK8B,gBAAgBvB,EAAQe,GAExDf,EAAM7C,EAAA,GAAQ4D,GACdN,EAAYxD,KAAK8D,GACjB,IA2CYS,EA3CRC,EAAQhC,EAAKiC,SAASX,EAAGI,IAAKJ,EAAGC,KAEjCJ,GACe,OAAXG,EAAGK,KACHT,EAAQgB,SAAU,EAClBhB,EAAQiB,OAAS,CAAA,GAAAC,OAAA1G,EAAKsG,GAAL,CAAYV,EAAGO,eAEhCX,EAAQgB,SAAU,EAClBhB,EAAQiB,OAAS,CAAA,GAAAC,OAAA1G,EAAKsG,GAAL,CAAYV,EAAGO,UAAWP,EAAGK,QAElDR,GAAU,GAEK,OAAXG,EAAGK,IACCT,EAAQgB,SAERtD,EAAAoB,EAAIZ,EAAAZ,EAAJwB,EAAIZ,GAAmB8B,EAAQiB,OAAOjH,QACtCsD,EAAAwB,EAAIf,GAAmBzB,KAAK0D,IAC5BA,EAAU,CACVA,SAAkB,IACViB,OAAS,CAAA,GAAAC,OAAA1G,EAAKsG,GAAL,CAAYV,EAAGO,cAEhCX,EAAQiB,OAAO3E,KAAf,GAAA4E,OAAA1G,EAAwBsG,GAAxB,CAA+BV,EAAGO,aAGjCX,EAAQgB,QAOThB,EAAQiB,OAAO3E,KAAf,GAAA4E,OAAA1G,EACOsG,GADP,CAEIV,EAAGO,UACHP,EAAGK,QATP/C,EAAAoB,EAAIX,EAAAb,EAAJwB,EAAIX,GAAsB6B,EAAQiB,OAAOjH,QACzCsD,EAAAwB,EAAIf,GAAmBzB,KAAK0D,IAC5BA,EAAU,CACVA,SAAkB,IACViB,OAAS,CAAA,GAAAC,OAAA1G,EAAKsG,GAAL,CAAYV,EAAGO,UAAWP,EAAGK,QAW3C,OAAXL,EAAGK,MACa,OAAZP,KAEIW,EAAOT,EAAGK,IAAMP,GACT,EACPN,GAAQiB,EACM,EAAPA,IACPlB,GAAQkB,IAIZvB,EAAMc,EAAGK,MACTnB,EAAMc,EAAGK,KAGThB,EAAMW,EAAGK,MACThB,EAAMW,EAAGK,KAEbP,EAAUE,EAAGK,OAIjBT,IACIA,EAAQgB,QACRtD,EAAAoB,EAAIZ,EAAAZ,EAAJwB,EAAIZ,GAAmB8B,EAAQiB,OAAOjH,QAEtC0D,EAAAoB,EAAIX,EAAAb,EAAJwB,EAAIX,GAAsB6B,EAAQiB,OAAOjH,QAE7CsD,EAAAwB,EAAIf,GAAmBzB,KAAK0D,IAGI,IAAhC1C,EAAAwB,EAAIf,GAAmB/D,OACvB,KAAM,0DAId0D,EAAA1E,KAAAmI,EAAkB,CACdnH,OAAQhB,KAAKoI,iBACb9B,IAAKA,EACLG,IAAKA,EACLE,KAAMA,EACNC,KAAMA,IAGC,GAAGxE,MAAMrB,KAAKgF,EAAUK,iBAAiB,QAE/CxC,QAAQ,SAACyE,GAEV,IAAIC,EAAOxC,EAAK4B,iBAAiBW,EAAK,QAClCE,EAASzC,EAAKiC,SACdT,WAAWe,EAAId,aAAa,QAC5BD,WAAWe,EAAId,aAAa,SAGhCjD,EAAAwB,EAAIL,GAAYnC,KAAK,CACjBjB,KAAMyD,EAAK4B,iBAAiBW,EAAK,SAAW,KAC5ClF,IAAK2C,EAAK4B,iBAAiBW,EAAK,QAAU,KAC1Cb,IAAKe,EAAO,GACZlB,IAAKkB,EAAO,GACZd,IAAKH,WAAWxB,EAAK4B,iBAAiBW,EAAK,SAAW,KACtDC,KAAc,MAARA,EAAe,KAAO,IAAIE,KAAKF,OAI7C5D,EAAA1E,KAAAoF,EAAuBd,EAAAtE,KAAAyF,GAAgBzE,QAEvC0D,EAAA1E,KAAAiF,EACIjF,KAAKyI,gBACLzI,KAAK0I,iBACL1I,KAAK2I,kBAET3I,KAAK4I,eACE5I,ODpHXoF,CACEnB,IAAAA,mBACAH,MAAAA,SC6He+E,EAAiBC,GAC9B,IAAIC,EAAOF,EAAOG,cAAcF,GAChC,OAAY,MAARC,EACyBE,MAAlBF,EAAKG,UACNH,EAAKG,UAELH,EAAKI,WAAW,GAAGC,KAEtBL,IDwEV,CCxPGrE,IAAAA,kBD0PJZ,MAAO,SC/DSuF,EAAgBC,GAC5B,IAAIC,EAAU,GACdA,EAAQlC,IAAMgC,EAAKhC,IACnBkC,EAAQ/B,IAAM6B,EAAK7B,IACnB,IAAIgC,EAAU,GACdA,EAAQnC,IAAMiC,EAAKjC,IACnBmC,EAAQhC,IAAM8B,EAAK9B,IACnB,IAAIiC,EAAMC,KAAKC,GAAK,IAChBC,EAAOL,EAAQlC,IAAMoC,EACrBI,EAAOL,EAAQnC,IAAMoC,EACrBK,EAAUJ,KAAKK,KAAMP,EAAQnC,IAAMkC,EAAQlC,KAAOoC,EAAO,GACzDO,EAAUN,KAAKK,KAAMP,EAAQhC,IAAM+B,EAAQ/B,KAAOiC,EAAO,GACzD9I,EACImJ,EAAUA,EACVJ,KAAKO,IAAIL,GAAQF,KAAKO,IAAIJ,GAAQG,EAAUA,EAEpD,OAAO,SADC,EAAIN,KAAKQ,MAAMR,KAAKS,KAAKxJ,GAAI+I,KAAKS,KAAK,EAAIxJ,OAhL/CoG,CACIlD,IAAA,WACAC,MAAA,WAwLR,MAAA,GAAAoE,OAAA5D,EAAUtE,KAAV4E,GAAA,KAAAsD,OAAA5D,EAA8BtE,KAA9B8E,GAAA,OA7KYsC,CAEIf,IAAAA,gBACPvC,MAAA,WAkLT,OAAO9D,KAAKoK,WAAWpJ,OAAS,IA3KhBgG,CACAA,IAAAA,iBAFJlD,MAAA,WAqLZ,IAAMuG,EAAgB/F,EAAAtE,KAAA+E,GAAuB/D,OACzCsJ,EAAgB,EAkBpB,OAhBoB,EAAhBD,IAEAC,GAAiC,EAAhBD,EAEjBC,GAAiB,EACS,EAAtBhG,EAAAtE,KAAAkF,KAEAoF,GAAiB,IAGrBA,GACoB,EAAhBD,EACyB,EAAzB/F,EAAAtE,KAAAmF,GACsB,EAAtBb,EAAAtE,KAAAkF,IAGDoF,IDyEV,CCzPuBtD,IAAAA,iBACAA,MAAAA,WAuLpB,IAAIuD,EAAgB,EAUpB,OARAjG,EAAAtE,KAAAyF,GAAgB7B,QAAQ,SAAC4G,GACrBD,GACI,IACCC,EAAS/C,IAAM,EAAI,IACnB+C,EAASrH,IAAMqH,EAASrH,IAAInC,OAAS,IACrCwJ,EAASnI,KAAOmI,EAASnI,KAAKrB,OAAS,KAGzCuJ,IAhLa3D,CADJ/C,IAAA,oBAGI8C,MAAAA,WAsLpB,OAA6B,EAAtBrC,EAAAtE,KAAAkF,KDyEV,CACDrB,IAAK,gBCxPWC,MAAA,WAsLZ,OAAAQ,EAAOtE,KAAPiF,KA/KI,CACIpB,IAAA,UACIa,MAAAA,SAoLR0E,GAAc,IAAAqB,EAClBnG,EAAAtE,KAAAqF,GAAWqF,UAAXhG,EAAoB1E,KAApB2K,EAAA,GAAAF,GAAAnG,EAAoBtE,KAApB2K,KAAAF,GAAwCrB,KAjRxC,CDkWJvF,IAAK,UC1PDa,MAAAA,WAiLc,IAAAkG,EACd,OAAOtG,EAAAtE,KAAAqF,GAAWwF,UAAXnG,EAAoB1E,KAApB2K,EAAA,GAAAC,GAAAtG,EAAoBtE,KAApB2K,KAAAC,MAvKH,CACA/G,IAAA,WD2PRC,MAAO,SC9EEsF,GACL9E,EAAAtE,KAAAqF,GAAWyF,UAAXxG,EAAqBtE,KAArB2K,GAAuCvB,GAAM,GAC7C1E,EAAA1E,KAAA2K,EAAArG,EAAAtE,KAAA2K,GAAoB,KAjLpB,CDyQJ9G,IAAK,WCvPDa,MAAAA,WAwKA,IAAIqG,EAAGzG,EAAGtE,KAAH2K,GAEP,OADAjG,EAAA1E,KAAA2K,EAAArG,EAAAtE,KAAA2K,GAAoB,GACbrG,EAAAtE,KAAAqF,GAAW2F,UAAUD,GAAK,KD0FpC,CACDlH,IAAK,UACLC,MAAO,SCrFCsF,GACJ9E,EAAAtE,KAAAqF,GAAW4F,SAAX3G,EAAoBtE,KAApB2K,GAAsCvB,GAAM,GAC5C1E,EAAA1E,KAAA2K,EAAArG,EAAAtE,KAAA2K,GAAoB,KD8FvB,CCtPG9G,IAAA,UACHC,MAAA,WAgKG,IAAIiH,EAAGzG,EAAGtE,KAAH2K,GAEP,OADAjG,EAAA1E,KAAA2K,EAAArG,EAAAtE,KAAA2K,GAAoB,GACbrG,EAAAtE,KAAAqF,GAAW6F,SAASH,GAAK,KDzFpCjH,CC9DID,IAAA,WACA0F,MAAAA,SA6JKH,GACL9E,EAAAtE,KAAAqF,GAAW8F,UAAX7G,EAAqBtE,KAArB2K,GAAuCvB,GAAM,GAC7C1E,EAAA1E,KAAA2K,EAAArG,EAAAtE,KAAA2K,GAAoB,KA1JpB,CASA9G,IAAA,WACHC,MAAA,WAyJG,IAAIiH,EAAGzG,EAAGtE,KAAH2K,GAEP,OADAjG,EAAA1E,KAAA2K,EAAArG,EAAAtE,KAAA2K,GAAoB,GACbrG,EAAAtE,KAAAqF,GAAW+F,UAAUL,GAAK,KAhJrC,CDyPAlH,IAAK,UACLC,MAAO,SCnGCsF,GACJ9E,EAAAtE,KAAAqF,GAAWgG,SAAX/G,EAAoBtE,KAApB2K,GAAsCvB,GAAM,GAC5C1E,EAAA1E,KAAA2K,EAAArG,EAAAtE,KAAA2K,GAAoB,KD4GvB,CACD9G,IAAK,UACLC,MAAO,WCrGH,IAAIiH,EAAGzG,EAAGtE,KAAH2K,GAEP,OADAjG,EAAA1E,KAAA2K,EAAArG,EAAAtE,KAAA2K,GAAoB,GACbrG,EAAAtE,KAAAqF,GAAWiG,SAASP,GAAK,KDqHnC,CC9POT,IAAAA,WAIHxG,MAAA,SAkJI0D,EAAaH,GAClB,IAAMoC,EAAMC,KAAKC,GAAK,IAItB,MAAO,CAFG,QAINnC,EAAUiC,EAJJ,QAMFC,KAAK6B,MAAM7B,KAAKK,IAAI1C,EAAMoC,OD8GrC,CC7PGnF,IAAAA,eACIiG,MAAAA,WAsJJ,OAAA/G,EAAAA,EAAA,GAAAc,EACOtE,KADPmI,IAAA,GAAA,CAEIqD,YAAa,CACTxD,QAAO1D,EAAEtE,KAAFkF,GACPuG,WAAUnH,EAAEtE,KAAFmF,QD1EtBrB,CCjEID,IAAA,WACHC,MAAA,WAmJG,OAAAQ,EAAOtE,KAAP+E,KD1EJlB,CACAC,IAAAA,eCnEIA,MAAA,WAmJA,OAAAQ,EAAOtE,KAAPyF,KDlFH,CAWD5B,IAAAA,iBACAC,MAAAA,WC6EI,IAAM4H,EAAcpH,EAAAtE,KAAA+E,GAChBT,EAAAtE,KAAA+E,GAAuB/D,OAAS,GAClCiH,OACF,OAAOyD,EAAYA,EAAY1K,OAAS,GAAG,KDoH9C,CAtMA6C,IAjToB,eA+TrBA,MAAAA,WC2EyB,IAAA8H,EAAA3L,KACrB,GAAwB,GAApBsE,EAAAtE,KAAAiF,GACA,KAAM,qDAEVP,EAAA1E,KAAAgF,EAAe,IAAI4G,YAAJtH,EAAgBtE,KAAhBiF,KACfP,EAAA1E,KAAAqF,EAAa,IAAIwG,SAAJvH,EAAatE,KAAbgF,KACb,IAAM8G,EAAM,IAAIC,YACVC,EAAU,CACZhE,QAAS8D,EAAIG,OAAO,KAAK,GACzBR,WAAYK,EAAIG,OAAO,KAAK,GAC5BC,UAAWJ,EAAIG,OAAO,MAAM,IAK1BE,EAAUL,EAAIG,OAAOjM,KAAKoK,YAChC1F,EAAA1E,KAAA2K,EAAmB,GAEnBwB,EAAQvI,QAAQ,SAACpD,GACbmL,EAAKS,QAAQ5L,KAEjB,IAAM6J,EAAgB/F,EAAAtE,KAAA+E,GAAuB/D,OAC7C,GAAoB,IAAhBqJ,EACA,KAAM,0DAGV,GADArK,KAAKoM,QAAQ/B,GACc,MAAvB/F,EAAAtE,KAAAoF,GACA,KAAM,2DA4FV,GA1FApF,KAAKqM,SAAL/H,EAActE,KAAdoF,IAIAd,EAAAtE,KAAA+E,GAAuBnB,QAAQ,SAACoD,GAC5B,IAAIxG,EAAIwG,EAAQgB,QAAUgE,EAAQhE,QAAUgE,EAAQP,WACpDE,EAAKS,QAAQ5L,GAEbmL,EAAKW,SAAStF,EAAQiB,OAAOjH,UAKjChB,KAAKsM,SAAS5C,KAAK6C,MAAMjI,EAAAtE,KAAAmI,GAAgBnH,SACrChB,KAAKwM,sBAELxM,KAAKyM,QAAQ/C,KAAK6C,MAAMjI,EAAAtE,KAAAmI,GAAgB7B,MAExCtG,KAAKyM,QAAQ/C,KAAK6C,MAAMjI,EAAAtE,KAAAmI,GAAgB1B,MAExCzG,KAAKsM,SAAS5C,KAAK6C,MAAMjI,EAAAtE,KAAAmI,GAAgBxB,OAEzC3G,KAAKsM,SAAS5C,KAAK6C,MAAMjI,EAAAtE,KAAAmI,GAAgBvB,QAK7CtC,EAAAtE,KAAA+E,GAAuBnB,QAAQ,SAACoD,GAC5B,IAAI0F,EAAY,KAChB1F,EAAQiB,OAAOrE,QAAQ,SAAC+I,GACpB,GAAkB,OAAdD,EACAf,EAAKiB,QAAQlD,KAAK6C,MAAMI,EAAM,KAC9BhB,EAAKiB,QAAQlD,KAAK6C,MAAMI,EAAM,KAG9BhB,EAAKU,SAAS3C,KAAK6C,MAAMI,EAAM,GAAK,SACjC,CAEH,IAAME,EACEnD,KAAK6C,MAAMI,EAAM,IAAMjD,KAAK6C,MAAMG,EAAU,IAChDI,EACIpD,KAAK6C,MAAMI,EAAM,IAAMjD,KAAK6C,MAAMG,EAAU,IAIpD,GADe,MAEXG,GACAA,GAJa,OACF,MAIXC,GACAA,GANa,MAQb,KAAM,4DAEVnB,EAAKc,QAAQ/C,KAAK6C,MAAMM,IACxBlB,EAAKc,QAAQ/C,KAAK6C,MAAMO,IACxBnB,EAAKU,SAAS3C,KAAK6C,MAAMI,EAAM,GAAK,KAExCD,EAAYC,EAER3F,EAAQgB,SACR2D,EAAKc,QAAQ/C,KAAK6C,MAAMI,EAAM,SAO1CrI,EAAAtE,KAAAyF,GAAgB7B,QAAQ,SAAC4G,GACrBmB,EAAKiB,QAAQlD,KAAK6C,MAAM/B,EAAShD,MACjCmE,EAAKiB,QAAQlD,KAAK6C,MAAM/B,EAASnD,MACjCsE,EAAKS,QAAQ5B,EAAS/C,IAAMuE,EAAQhE,QAAUgE,EAAQP,YAClDjB,EAAS/C,KACTkE,EAAKc,QAAQ/C,KAAK6C,MAAM/B,EAAS/C,MAEjC+C,EAASrH,KACO2I,EAAIG,OAAOzB,EAASrH,KAC5BS,QAAQ,SAACpD,GACbmL,EAAKS,QAAQ5L,KAGrBmL,EAAKS,QAAQJ,EAAQE,WACjB1B,EAASnI,MACQyJ,EAAIG,OAAOzB,EAASnI,MAC5BuB,QAAQ,SAACpD,GACdmL,EAAKS,QAAQ5L,KAGrBmL,EAAKS,QAAQJ,EAAQE,aAGrB5H,EAAAtE,KAAA2K,IAAArG,EAAoBtE,KAApBiF,GACA,KAAM,gFAGV,OAAOjF,OA5JCyL,CAFS5H,IAAA,YAFjBC,MAAA,WAwKA,OAAAQ,EAAOtE,KAAPgF,KA1JH,CAEDnB,IAAA,kBDoSAC,MAAO,WClIH,IAAIQ,EAACtE,KAADgF,GACA,OAAO,EAEX,IAAM+H,EAAM,IAAIC,YACVC,EAAW,IAAIC,WAAJ5I,EACbtE,KADagF,GAEb,EACAhF,KAAKoK,WAAWpJ,QAEpB,OAAOhB,KAAKoK,YAAc2C,EAAII,OAAOF,KDyIxC,CCtSGpJ,IAAA,eACHC,MAAA,SAqKYsJ,GACT,IAAKA,EACD,KAAM,4CAEV1I,EAAA1E,KAAAgF,EAAeoI,GACf,IAAIC,EAAc,IAAIH,WAAWE,GAKjC,GAJA1I,EAAA1E,KAAAiF,EAAmBoI,EAAYrM,SAI1BhB,KAAKsN,kBACN,KAAM,2CAGV,IAAMxB,EAAM,IAAIC,YACVC,EACOF,EAAIG,OAAO,KAAK,GADvBD,EAEUF,EAAIG,OAAO,KAAK,GAF1BD,EAGSF,EAAIG,OAAO,MAAM,GAGhCvH,EAAA1E,KAAAqF,EAAa,IAAIwG,SAAJvH,EAAatE,KAAbgF,KACbN,EAAA1E,KAAA2K,EAAmB3K,KAAKoK,WAAWpJ,QACnC,IAAMqJ,EAAgBrK,KAAKuN,UAC3B7I,EAAA1E,KAAAoF,EAAuBpF,KAAKwN,YAC5B9I,EAAA1E,KAAA+E,EAAyB,IAAIpD,MAAM0I,IACnC3F,EAAA1E,KAAAkF,EAAsB,GACtBR,EAAA1E,KAAAmF,EAAyB,GAIzB,IAAK,IAyBGnE,EAzBCT,EAAI,EAAGA,EAAI8J,EAAe9J,IAAK,CACpC,IAAIkN,EAAczN,KAAKuN,UACnBtF,EAASjI,KAAK0N,WACd1F,OAAO,EACX,OAAQyF,GACJ,KAAKzB,EACDhE,GAAU,EACVtD,EAAA1E,KAAAkF,EAAAZ,EAAAtE,KAAAkF,GAAuB+C,GACvB,MACJ,KAAK+D,EACDhE,GAAU,EACVtD,EAAA1E,KAAAmF,EAAAb,EAAAtE,KAAAmF,GAA0B8C,GAC1B,MACJ,QACI,KAAM,4CAEd3D,EAAAtE,KAAA+E,GAAuBxE,GAAK,CACxByH,QAASA,EACTC,OAAQ,IAAItG,MAAMsG,IAMtBoC,GACIrJ,EAAShB,KAAK0N,WACd1N,KAAKwM,oBACL9H,EAAA1E,KAAAmI,EAAkB,CACdnH,OAAQA,EACRsF,IAAKtG,KAAK2N,UACVlH,IAAKzG,KAAK2N,UACVhH,KAAM3G,KAAK0N,WACX9G,KAAM5G,KAAK0N,aAGfhJ,EAAA1E,KAAAmI,EAAkB,CACdnH,OAAQA,KAIhB0D,EAAA1E,KAAAmI,EAAkB,IAKtB,IAAK,IAAIyF,EAAI,EAAGA,EAAIvD,EAAeuD,IAM/B,IALA,IAAMC,EAAuBvJ,EAAAtE,KAAA+E,GAAuB6I,GAAG3F,OAClDjH,OACC8M,EAAaxJ,EAAAtE,KAAA+E,GAAuB6I,GAAG5F,QACzC0E,EAAY,KAEP5L,EAAI,EAAGA,EAAI+M,EAAsB/M,IAElC4L,EADc,OAAdA,EACY,CACR1M,KAAK+N,UACL/N,KAAK+N,UACa,GAAlB/N,KAAKwN,YAGG,CACRxN,KAAK2N,UAAYjB,EAAU,GAC3B1M,KAAK2N,UAAYjB,EAAU,GACT,GAAlB1M,KAAKwN,YAGTM,IACApB,EAAS,GAAAxE,OAAA1G,EAAOkL,GAAP,CAAkB1M,KAAK2N,aAEpCrJ,EAAAtE,KAAA+E,GAAuB6I,GAAG3F,OAAOnH,GAAK4L,EAM9C,IAAMK,EAAM,IAAIC,YAChBtI,EAAA1E,KAAAyF,EAAkB,IAAI9D,MAAJ2C,EAAUtE,KAAVoF,KAClB,IAAK,IAAI4I,EAAI,EAAGA,EAAC1J,EAAGtE,KAAHoF,GAAyB4I,IAAK,CAC3C,IAAI3F,EAAM,CACNb,IAAKxH,KAAK+N,UACV1G,IAAKrH,KAAK+N,WAGd,OAAQ/N,KAAKuN,WACT,KAAKvB,EACD3D,EAAG7E,EAAAA,EAAA,GAAQ6E,GAAR,GAAA,CAAaZ,IAAKzH,KAAK2N,YAC1B,MACJ,KAAK3B,EACD,MACJ,QACI,KAAM,6CAId,IADA,IAAIvK,EAAM,GAEFjB,EAAIR,KAAKuN,UACb/M,GAAKwL,EACLxL,EAAIR,KAAKuN,UAET9L,EAAI6B,KAAK9C,GAMb,IAJA,IAAIyN,EAAQ,IAAIf,WAAWzL,GACvB0B,EAAM4J,EAAII,OAAOc,GAErBxM,EAAM,GAEEyM,EAAIlO,KAAKuN,UACbW,GAAKlC,EACLkC,EAAIlO,KAAKuN,UAET9L,EAAI6B,KAAK4K,GAEbD,EAAQ,IAAIf,WAAWzL,GACvB,IAAIY,EAAO0K,EAAII,OAAOc,GAEtB3J,EAAAtE,KAAAyF,GAAgBuI,GAAhBxK,EAAAA,EAAA,GAA0B6E,GAA1B,GAAA,CAA+BlF,IAAKA,EAAKd,KAAMA,IAGnD,OAAOrC,UFj1BfmO,EAAA5I,EAAAhE,UAAAoE,GAAAC,GAAAuI,EAAA5I,EAAAK,GCk+BS3F,EA39B2C,GC+0B9B,iBAAlB,IAAOP,EAAP,YAAAwB,EAAOxB,KAAuBA,EAAOF,UAErCE,EAAOF,QAAUS,IDmJnB,KAAK,GAAG,CAAC,GD3+BX,CC2+Be","file":"webtrack.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.WebTrack = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError(\"attempted to get private field on non-instance\"); } if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError(\"attempted to set private field on non-instance\"); } if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\nvar _formatName = new WeakMap();\n\nvar _formatVersion = new WeakMap();\n\nvar _reformatedTracks = new WeakMap();\n\nvar _waypoints = new WeakMap();\n\nvar _trackInfo = new WeakMap();\n\nvar _buffer = new WeakMap();\n\nvar _bufferSize = new WeakMap();\n\nvar _pointsWithEle = new WeakMap();\n\nvar _pointsWithoutEle = new WeakMap();\n\nvar _currentPos = new WeakMap();\n\nvar _totalWaypoints = new WeakMap();\n\nvar _view = new WeakMap();\n\n/*!\n * MIT License\n *\n * Copyright (c) 2020 Clement\n * Copyright (c) 2018 Lucas Trebouet Voisin\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/** Interface with the WebTrack file format. */\nvar WebTrack = /*#__PURE__*/function () {\n  function WebTrack() {\n    _classCallCheck(this, WebTrack);\n\n    _formatName.set(this, {\n      writable: true,\n      value: \"webtrack-bin\"\n    });\n\n    _formatVersion.set(this, {\n      writable: true,\n      value: \"0.1.0\"\n    });\n\n    _reformatedTracks.set(this, {\n      writable: true,\n      value: []\n    });\n\n    _waypoints.set(this, {\n      writable: true,\n      value: []\n    });\n\n    _trackInfo.set(this, {\n      writable: true,\n      value: {}\n    });\n\n    _buffer.set(this, {\n      writable: true,\n      value: null\n    });\n\n    _bufferSize.set(this, {\n      writable: true,\n      value: 0\n    });\n\n    _pointsWithEle.set(this, {\n      writable: true,\n      value: 0\n    });\n\n    _pointsWithoutEle.set(this, {\n      writable: true,\n      value: 0\n    });\n\n    _currentPos.set(this, {\n      writable: true,\n      value: 0\n    });\n\n    _totalWaypoints.set(this, {\n      writable: true,\n      value: 0\n    });\n\n    _view.set(this, {\n      writable: true,\n      value: void 0\n    });\n  }\n\n  _createClass(WebTrack, [{\n    key: \"loadGPX\",\n\n    /**\n     * Load a GPX string and create a WebTrack buffer.\n     * @param gpxString The GPX string.\n     * @return this\n     */\n    value: function loadGPX(gpxString) {\n      var _this = this;\n\n      _classPrivateFieldSet(this, _reformatedTracks, []);\n\n      _classPrivateFieldSet(this, _waypoints, []);\n\n      _classPrivateFieldSet(this, _pointsWithEle, 0);\n\n      _classPrivateFieldSet(this, _pointsWithoutEle, 0);\n\n      var domParser = new window.DOMParser();\n      var xmlSource = domParser.parseFromString(gpxString.trim(), \"text/xml\");\n      var trks = [].slice.call(xmlSource.querySelectorAll(\"trk\"));\n      var prevPt = {};\n      var min = Number.POSITIVE_INFINITY,\n          max = Number.NEGATIVE_INFINITY,\n          gain = 0,\n          loss = 0;\n      trks.forEach(function (trk) {\n        // loop over <trk/>\n        var trackpoints = [];\n        var trkpts = [].slice.call(trk.querySelectorAll(\"trkpt\"));\n        var segment = {};\n        var isFirst = true;\n        var prevEle = null;\n        trkpts.forEach(function (trkpt) {\n          // loop over <trkpt/>\n          var pt = {};\n          pt.lat = parseFloat(trkpt.getAttribute(\"lat\"));\n          pt.lon = parseFloat(trkpt.getAttribute(\"lon\"));\n          pt.ele = parseFloat(_this._getElementValue(trkpt, \"ele\")) || null;\n\n          if (Object.keys(prevPt).length === 0 && prevPt.constructor === Object) {\n            pt.cumulDist = 0.0;\n          } else {\n            pt.cumulDist = //$FlowIgnore[unsafe-addition] operation with satisfying conditions\n            prevPt.cumulDist + _this.distanceBetween(prevPt, pt);\n          }\n\n          prevPt = _objectSpread({}, pt);\n          trackpoints.push(pt);\n\n          var webPt = _this.gpsToWeb(pt.lon, pt.lat);\n\n          if (isFirst) {\n            if (pt.ele === null) {\n              segment.withEle = false;\n              segment.points = [[].concat(_toConsumableArray(webPt), [pt.cumulDist])];\n            } else {\n              segment.withEle = true;\n              segment.points = [[].concat(_toConsumableArray(webPt), [pt.cumulDist, pt.ele])];\n            }\n\n            isFirst = false;\n          } else {\n            if (pt.ele === null) {\n              if (segment.withEle) {\n                // split\n                _classPrivateFieldSet(_this, _pointsWithEle, _classPrivateFieldGet(_this, _pointsWithEle) + segment.points.length);\n\n                _classPrivateFieldGet(_this, _reformatedTracks).push(segment);\n\n                segment = {}; // fresh segment\n\n                segment.withEle = false;\n                segment.points = [[].concat(_toConsumableArray(webPt), [pt.cumulDist])];\n              } else {\n                segment.points.push([].concat(_toConsumableArray(webPt), [pt.cumulDist]));\n              }\n            } else {\n              if (!segment.withEle) {\n                _classPrivateFieldSet(_this, _pointsWithoutEle, _classPrivateFieldGet(_this, _pointsWithoutEle) + segment.points.length);\n\n                _classPrivateFieldGet(_this, _reformatedTracks).push(segment);\n\n                segment = {};\n                segment.withEle = true;\n                segment.points = [[].concat(_toConsumableArray(webPt), [pt.cumulDist, pt.ele])];\n              } else {\n                segment.points.push([].concat(_toConsumableArray(webPt), [pt.cumulDist, pt.ele]));\n              }\n            }\n          }\n\n          if (pt.ele !== null) {\n            if (prevEle !== null) {\n              //$FlowIgnore[unsafe-addition]\n              var diff = pt.ele - prevEle;\n\n              if (diff < 0) {\n                loss -= diff;\n              } else if (diff > 0) {\n                gain += diff;\n              }\n            } //$FlowIgnore[invalid-compare]\n\n\n            if (min > pt.ele) {\n              min = pt.ele;\n            } //$FlowIgnore[invalid-compare]\n\n\n            if (max < pt.ele) {\n              max = pt.ele;\n            }\n\n            prevEle = pt.ele;\n          }\n        });\n\n        if (segment) {\n          if (segment.withEle) {\n            _classPrivateFieldSet(_this, _pointsWithEle, _classPrivateFieldGet(_this, _pointsWithEle) + segment.points.length);\n          } else {\n            _classPrivateFieldSet(_this, _pointsWithoutEle, _classPrivateFieldGet(_this, _pointsWithoutEle) + segment.points.length);\n          }\n\n          _classPrivateFieldGet(_this, _reformatedTracks).push(segment);\n        }\n\n        if (_classPrivateFieldGet(_this, _reformatedTracks).length > 255) {\n          throw \"Failed to load the GPX string: exceeding 255 segments\";\n        }\n      });\n\n      _classPrivateFieldSet(this, _trackInfo, {\n        length: this.getTrackLength(),\n        min: min,\n        max: max,\n        gain: gain,\n        loss: loss\n      });\n\n      var wpts = [].slice.call(xmlSource.querySelectorAll(\"wpt\"));\n      wpts.forEach(function (wpt) {\n        // loop over <wpt/>\n        var time = _this._getElementValue(wpt, \"time\");\n\n        var coords = _this.gpsToWeb(parseFloat(wpt.getAttribute(\"lon\")), parseFloat(wpt.getAttribute(\"lat\")));\n\n        _classPrivateFieldGet(_this, _waypoints).push({\n          name: _this._getElementValue(wpt, \"name\") || null,\n          sym: _this._getElementValue(wpt, \"sym\") || null,\n          lon: coords[0],\n          lat: coords[1],\n          ele: parseFloat(_this._getElementValue(wpt, \"ele\")) || null,\n          time: time == null ? null : new Date(time)\n        });\n      });\n\n      _classPrivateFieldSet(this, _totalWaypoints, _classPrivateFieldGet(this, _waypoints).length);\n\n      _classPrivateFieldSet(this, _bufferSize, this._fmtArraySize() + this._trksArraySize() + this._wptsArraySize());\n\n      this.createBuffer();\n      return this;\n    }\n    /**\n     * Get value from a XML DOM element\n     *\n     * @param  {Element} parent - Parent DOM Element\n     * @param  {string} needle - Name of the searched element\n     *\n     * @return The element value\n     */\n\n  }, {\n    key: \"_getElementValue\",\n    value: function _getElementValue(parent, needle) {\n      var elem = parent.querySelector(needle);\n\n      if (elem != null) {\n        return elem.innerHTML != undefined ? elem.innerHTML : //$FlowIgnore[prop-missing]\n        elem.childNodes[0].data;\n      }\n\n      return elem;\n    }\n    /**\n     * Compute the dstance between two points.\n     *\n     * @param  {WayPoint} wpt1 - A geographic point with lat and lon properties\n     * @param  {WayPoint} wpt2 - A geographic point with lat and lon properties\n     *\n     * @returns {float} The distance between the two points\n     */\n\n  }, {\n    key: \"distanceBetween\",\n    value: function distanceBetween(wpt1, wpt2) {\n      var latlng1 = {};\n      latlng1.lat = wpt1.lat;\n      latlng1.lon = wpt1.lon;\n      var latlng2 = {};\n      latlng2.lat = wpt2.lat;\n      latlng2.lon = wpt2.lon;\n      var rad = Math.PI / 180,\n          lat1 = latlng1.lat * rad,\n          lat2 = latlng2.lat * rad,\n          sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),\n          sinDLon = Math.sin((latlng2.lon - latlng1.lon) * rad / 2),\n          a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,\n          c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n      return 6371008 * c;\n    }\n    /**\n     * Returns the first characters that should be in the WebTrack file.\n     * Example: 'webtrack-bin:0.1.2:'\n     * @return ASCII characters.\n     */\n\n  }, {\n    key: \"_fmtText\",\n    value: function _fmtText() {\n      return \"\".concat(_classPrivateFieldGet(this, _formatName), \":\").concat(_classPrivateFieldGet(this, _formatVersion), \":\");\n    }\n    /**\n     * Returns the length in bytes of the \"Format Information\" section.\n     * @return Number of bytes.\n     */\n\n  }, {\n    key: \"_fmtArraySize\",\n    value: function _fmtArraySize() {\n      return this._fmtText().length + 3;\n    }\n    /**\n     * Returns the length in bytes of the \"Segment Headers\",\n     * plus the \"Track Information\", plus the \"Segment\" sections.\n     * @return Number of bytes.\n     */\n\n  }, {\n    key: \"_trksArraySize\",\n    value: function _trksArraySize() {\n      var totalSegments = _classPrivateFieldGet(this, _reformatedTracks).length;\n\n      var trksArraySize = 0;\n\n      if (totalSegments > 0) {\n        // segment headers:\n        trksArraySize += totalSegments * 5; // tracks info (length):\n\n        trksArraySize += 4;\n\n        if (_classPrivateFieldGet(this, _pointsWithEle) > 0) {\n          // tracks info (ele min/max/gain/loss):\n          trksArraySize += 12;\n        }\n\n        trksArraySize += totalSegments * 4 + _classPrivateFieldGet(this, _pointsWithoutEle) * 6 + _classPrivateFieldGet(this, _pointsWithEle) * 8;\n      }\n\n      return trksArraySize;\n    }\n    /**\n     * Returns the length in bytes of the \"Waypoints\" section.\n     * @return Number of bytes.\n     */\n\n  }, {\n    key: \"_wptsArraySize\",\n    value: function _wptsArraySize() {\n      var wptsArraySize = 0;\n\n      _classPrivateFieldGet(this, _waypoints).forEach(function (waypoint) {\n        wptsArraySize += 11 + (waypoint.ele ? 2 : 0) + (waypoint.sym ? waypoint.sym.length : 0) + (waypoint.name ? waypoint.name.length : 0);\n      });\n\n      return wptsArraySize;\n    }\n    /**\n     * Returns true if there is at least one point with elevation data.\n     * @return False if there isn't a single point with elevation, true otherwise.\n     */\n\n  }, {\n    key: \"someTracksWithEle\",\n    value: function someTracksWithEle() {\n      return _classPrivateFieldGet(this, _pointsWithEle) > 0;\n    }\n    /**\n     * Returns the size of the buffer.\n     * @return Number of bytes.\n     */\n\n  }, {\n    key: \"getBufferSize\",\n    value: function getBufferSize() {\n      return _classPrivateFieldGet(this, _bufferSize);\n    }\n    /**\n     * Append a uint8 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n\n  }, {\n    key: \"_wUint8\",\n    value: function _wUint8(data) {\n      var _this$currentPos;\n\n      _classPrivateFieldGet(this, _view).setUint8((_classPrivateFieldSet(this, _currentPos, (_this$currentPos = +_classPrivateFieldGet(this, _currentPos)) + 1), _this$currentPos), data);\n    }\n    /**\n     * Read a uint8 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The byte from the buffer.\n     */\n\n  }, {\n    key: \"_rUint8\",\n    value: function _rUint8() {\n      var _this$currentPos2;\n\n      return _classPrivateFieldGet(this, _view).getUint8((_classPrivateFieldSet(this, _currentPos, (_this$currentPos2 = +_classPrivateFieldGet(this, _currentPos)) + 1), _this$currentPos2));\n    }\n    /**\n     * Append a uint16 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n\n  }, {\n    key: \"_wUint16\",\n    value: function _wUint16(data) {\n      _classPrivateFieldGet(this, _view).setUint16(_classPrivateFieldGet(this, _currentPos), data, false);\n\n      _classPrivateFieldSet(this, _currentPos, _classPrivateFieldGet(this, _currentPos) + 2);\n    }\n    /**\n     * Read a uint16 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The bytes from the buffer.\n     */\n\n  }, {\n    key: \"_rUint16\",\n    value: function _rUint16() {\n      var pos = _classPrivateFieldGet(this, _currentPos);\n\n      _classPrivateFieldSet(this, _currentPos, _classPrivateFieldGet(this, _currentPos) + 2);\n\n      return _classPrivateFieldGet(this, _view).getUint16(pos, false);\n    }\n    /**\n     * Append a int16 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n\n  }, {\n    key: \"_wInt16\",\n    value: function _wInt16(data) {\n      _classPrivateFieldGet(this, _view).setInt16(_classPrivateFieldGet(this, _currentPos), data, false);\n\n      _classPrivateFieldSet(this, _currentPos, _classPrivateFieldGet(this, _currentPos) + 2);\n    }\n    /**\n     * Read a int16 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The bytes from the buffer.\n     */\n\n  }, {\n    key: \"_rInt16\",\n    value: function _rInt16() {\n      var pos = _classPrivateFieldGet(this, _currentPos);\n\n      _classPrivateFieldSet(this, _currentPos, _classPrivateFieldGet(this, _currentPos) + 2);\n\n      return _classPrivateFieldGet(this, _view).getInt16(pos, false);\n    }\n    /**\n     * Append a uint32 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n\n  }, {\n    key: \"_wUint32\",\n    value: function _wUint32(data) {\n      _classPrivateFieldGet(this, _view).setUint32(_classPrivateFieldGet(this, _currentPos), data, false);\n\n      _classPrivateFieldSet(this, _currentPos, _classPrivateFieldGet(this, _currentPos) + 4);\n    }\n    /**\n     * Read a uint32 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The bytes from the buffer.\n     */\n\n  }, {\n    key: \"_rUint32\",\n    value: function _rUint32() {\n      var pos = _classPrivateFieldGet(this, _currentPos);\n\n      _classPrivateFieldSet(this, _currentPos, _classPrivateFieldGet(this, _currentPos) + 4);\n\n      return _classPrivateFieldGet(this, _view).getUint32(pos, false);\n    }\n    /**\n     * Append a int32 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n\n  }, {\n    key: \"_wInt32\",\n    value: function _wInt32(data) {\n      _classPrivateFieldGet(this, _view).setInt32(_classPrivateFieldGet(this, _currentPos), data, false);\n\n      _classPrivateFieldSet(this, _currentPos, _classPrivateFieldGet(this, _currentPos) + 4);\n    }\n    /**\n     * Read a int32 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The bytes from the buffer.\n     */\n\n  }, {\n    key: \"_rInt32\",\n    value: function _rInt32() {\n      var pos = _classPrivateFieldGet(this, _currentPos);\n\n      _classPrivateFieldSet(this, _currentPos, _classPrivateFieldGet(this, _currentPos) + 4);\n\n      return _classPrivateFieldGet(this, _view).getInt32(pos, false);\n    }\n    /**\n     * Projection of a GPS point (EPSG:4326) into the Web Mercator (EPSG:3857).\n     * Formula based on:\n     * Title: Implementation Practice Web Mercator Map Projection\n     * Reference: NGA.SIG.0011_1.0.0_WEBMERC, 2014-02-18\n     * Author: National Geospatial Intelligence Agency (NGA)\n     * @param lon GPS longitude\n     * @param lat GPS latitude\n     * @return Web Mercator coordinates [easting, northing]\n     */\n\n  }, {\n    key: \"gpsToWeb\",\n    value: function gpsToWeb(lon, lat) {\n      var rad = Math.PI / 180; // ellipsoid semi-major axis [WSG 84 = 6378137m]:\n\n      var a = 6378137; // no parseInt to reduce drift when substracting coordinates:\n\n      return [// easting coordinate in the Web Mercator:\n      lon * a * rad, // northing coordinate in the Web Mercator:\n      a * Math.atanh(Math.sin(lat * rad))];\n    }\n    /**\n     * Returns essential information about the track.\n     */\n\n  }, {\n    key: \"getTrackInfo\",\n    value: function getTrackInfo() {\n      return _objectSpread(_objectSpread({}, _classPrivateFieldGet(this, _trackInfo)), {}, {\n        trackPoints: {\n          withEle: _classPrivateFieldGet(this, _pointsWithEle),\n          withoutEle: _classPrivateFieldGet(this, _pointsWithoutEle)\n        }\n      });\n    }\n    /**\n     * Returns an array of segments in the WebTrack format.\n     */\n\n  }, {\n    key: \"getTrack\",\n    value: function getTrack() {\n      return _classPrivateFieldGet(this, _reformatedTracks);\n    }\n    /**\n     * Returns an array of waypoints in the WebTrack format.\n     */\n\n  }, {\n    key: \"getWaypoints\",\n    value: function getWaypoints() {\n      return _classPrivateFieldGet(this, _waypoints);\n    }\n    /**\n     * Returns the length of the whole track.\n     */\n\n  }, {\n    key: \"getTrackLength\",\n    value: function getTrackLength() {\n      var lastSegment = _classPrivateFieldGet(this, _reformatedTracks)[_classPrivateFieldGet(this, _reformatedTracks).length - 1].points;\n\n      return lastSegment[lastSegment.length - 1][2];\n    }\n    /**\n     * Create a WebTrack buffer with the data fetched from the GPX string.\n     * @return A WebTrack buffer ready to be stored.\n     */\n\n  }, {\n    key: \"createBuffer\",\n    value: function createBuffer() {\n      var _this2 = this;\n\n      if (_classPrivateFieldGet(this, _bufferSize) == 0) {\n        throw \"Failed to create the WebTrack buffer: empty buffer\";\n      }\n\n      _classPrivateFieldSet(this, _buffer, new ArrayBuffer(_classPrivateFieldGet(this, _bufferSize)));\n\n      _classPrivateFieldSet(this, _view, new DataView(_classPrivateFieldGet(this, _buffer)));\n\n      var enc = new TextEncoder();\n      var encoded = {\n        withEle: enc.encode(\"E\")[0],\n        withoutEle: enc.encode(\"F\")[0],\n        separator: enc.encode(\"\\n\")[0]\n      }; // Format Information:\n\n      var fmtText = enc.encode(this._fmtText());\n\n      _classPrivateFieldSet(this, _currentPos, 0);\n\n      fmtText.forEach(function (c) {\n        _this2._wUint8(c);\n      });\n\n      var totalSegments = _classPrivateFieldGet(this, _reformatedTracks).length;\n\n      if (totalSegments > 255) {\n        throw \"Failed to create the WebTrack buffer: too many segments\";\n      }\n\n      this._wUint8(totalSegments);\n\n      if (_classPrivateFieldGet(this, _totalWaypoints) > 65535) {\n        throw \"Failed to create the WebTrack buffer: too many waypoints\";\n      }\n\n      this._wUint16(_classPrivateFieldGet(this, _totalWaypoints)); // Segment Headers:\n\n\n      _classPrivateFieldGet(this, _reformatedTracks).forEach(function (segment) {\n        var c = segment.withEle ? encoded.withEle : encoded.withoutEle;\n\n        _this2._wUint8(c); // Number of points written in big-endian:\n\n\n        _this2._wUint32(segment.points.length);\n      }); // Track Information:\n\n\n      this._wUint32(Math.round(_classPrivateFieldGet(this, _trackInfo).length));\n\n      if (this.someTracksWithEle()) {\n        //$FlowIgnore[incompatible-call] condition satisfied\n        this._wInt16(Math.round(_classPrivateFieldGet(this, _trackInfo).min)); //$FlowIgnore[incompatible-call] condition satisfied\n\n\n        this._wInt16(Math.round(_classPrivateFieldGet(this, _trackInfo).max)); //$FlowIgnore[incompatible-call] condition satisfied\n\n\n        this._wUint32(Math.round(_classPrivateFieldGet(this, _trackInfo).gain)); //$FlowIgnore[incompatible-call] condition satisfied\n\n\n        this._wUint32(Math.round(_classPrivateFieldGet(this, _trackInfo).loss));\n      } // Points from segments:\n\n\n      _classPrivateFieldGet(this, _reformatedTracks).forEach(function (segment) {\n        var prevPoint = null;\n        segment.points.forEach(function (point) {\n          if (prevPoint === null) {\n            _this2._wInt32(Math.round(point[0]));\n\n            _this2._wInt32(Math.round(point[1])); // cumulated distance:\n\n\n            _this2._wUint16(Math.round(point[2] / 10));\n          } else {\n            // rounding positions before diff to avoid drift\n            var deltaX = Math.round(point[0]) - Math.round(prevPoint[0]),\n                deltaY = Math.round(point[1]) - Math.round(prevPoint[1]);\n            var minDelta = -32768,\n                maxDelta = 32767;\n\n            if (deltaX > maxDelta || deltaX < minDelta || deltaY > maxDelta || deltaY < minDelta) {\n              throw \"Failed to create the WebTrack buffer: offset out or range\";\n            }\n\n            _this2._wInt16(Math.round(deltaX));\n\n            _this2._wInt16(Math.round(deltaY));\n\n            _this2._wUint16(Math.round(point[2] / 10));\n          }\n\n          prevPoint = point;\n\n          if (segment.withEle) {\n            _this2._wInt16(Math.round(point[3]));\n          }\n        });\n      }); // Points from waypoints:\n\n\n      _classPrivateFieldGet(this, _waypoints).forEach(function (waypoint) {\n        _this2._wInt32(Math.round(waypoint.lon));\n\n        _this2._wInt32(Math.round(waypoint.lat));\n\n        _this2._wUint8(waypoint.ele ? encoded.withEle : encoded.withoutEle);\n\n        if (waypoint.ele) {\n          _this2._wInt16(Math.round(waypoint.ele));\n        }\n\n        if (waypoint.sym) {\n          var symText = enc.encode(waypoint.sym);\n          symText.forEach(function (c) {\n            _this2._wUint8(c);\n          });\n        }\n\n        _this2._wUint8(encoded.separator);\n\n        if (waypoint.name) {\n          var nameText = enc.encode(waypoint.name);\n          nameText.forEach(function (c) {\n            _this2._wUint8(c);\n          });\n        }\n\n        _this2._wUint8(encoded.separator);\n      });\n\n      if (_classPrivateFieldGet(this, _currentPos) != _classPrivateFieldGet(this, _bufferSize)) {\n        throw \"Failed to create the WebTrack buffer: final position and buffer size mismatch\";\n      }\n\n      return this;\n    }\n    /**\n     * Returns the output buffer if not null, otherwise the input buffer.\n     * @return Buffer or null/undefined if both the input and the output buffer are null/undefined.\n     */\n\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer() {\n      return _classPrivateFieldGet(this, _buffer);\n    }\n    /**\n     * Check if the first bytes of the input buffer match the file format.\n     * Returns false if the input buffer is null or undefined.\n     * @see loadWebTrack()\n     * @return True if match, false otherwise\n     */\n\n  }, {\n    key: \"_formatInfoPass\",\n    value: function _formatInfoPass() {\n      if (!_classPrivateFieldGet(this, _buffer)) {\n        return false;\n      }\n\n      var dec = new TextDecoder();\n      var fmtInput = new Uint8Array(_classPrivateFieldGet(this, _buffer), 0, this._fmtText().length);\n      return this._fmtText() == dec.decode(fmtInput);\n    }\n    /**\n     * Load a buffer containing the WebTrack.\n     * The file format and version must be as defined by this class.\n     * @param webtrackBytes The WebTrack buffer\n     * @return this\n     */\n\n  }, {\n    key: \"loadWebTrack\",\n    value: function loadWebTrack(webtrackBytes) {\n      if (!webtrackBytes) {\n        throw \"Failed to load WebTrack: bad input buffer\";\n      }\n\n      _classPrivateFieldSet(this, _buffer, webtrackBytes);\n\n      var typedBuffer = new Uint8Array(webtrackBytes);\n\n      _classPrivateFieldSet(this, _bufferSize, typedBuffer.length); // Format Information:\n\n\n      if (!this._formatInfoPass()) {\n        throw \"Failed to load WebTrack: bad file format\";\n      }\n\n      var enc = new TextEncoder();\n      var encoded = {\n        withEle: enc.encode(\"E\")[0],\n        withoutEle: enc.encode(\"F\")[0],\n        separator: enc.encode(\"\\n\")[0]\n      }; //$FlowIgnore[incompatible-call] error thrown earlier if the buffer is null\n\n      _classPrivateFieldSet(this, _view, new DataView(_classPrivateFieldGet(this, _buffer)));\n\n      _classPrivateFieldSet(this, _currentPos, this._fmtText().length);\n\n      var totalSegments = this._rUint8();\n\n      _classPrivateFieldSet(this, _totalWaypoints, this._rUint16());\n\n      _classPrivateFieldSet(this, _reformatedTracks, new Array(totalSegments));\n\n      _classPrivateFieldSet(this, _pointsWithEle, 0);\n\n      _classPrivateFieldSet(this, _pointsWithoutEle, 0); // Segment Headers:\n\n\n      for (var i = 0; i < totalSegments; i++) {\n        var currSegType = this._rUint8(),\n            points = this._rUint32(),\n            withEle = void 0;\n\n        switch (currSegType) {\n          case encoded.withEle:\n            withEle = true;\n\n            _classPrivateFieldSet(this, _pointsWithEle, _classPrivateFieldGet(this, _pointsWithEle) + points);\n\n            break;\n\n          case encoded.withoutEle:\n            withEle = false;\n\n            _classPrivateFieldSet(this, _pointsWithoutEle, _classPrivateFieldGet(this, _pointsWithoutEle) + points);\n\n            break;\n\n          default:\n            throw \"Failed to load WebTrack: bad segment type\";\n        }\n\n        _classPrivateFieldGet(this, _reformatedTracks)[i] = {\n          withEle: withEle,\n          points: new Array(points)\n        };\n      } // Track Information:\n\n\n      if (totalSegments) {\n        var length = this._rUint32();\n\n        if (this.someTracksWithEle()) {\n          _classPrivateFieldSet(this, _trackInfo, {\n            length: length,\n            min: this._rInt16(),\n            max: this._rInt16(),\n            gain: this._rUint32(),\n            loss: this._rUint32()\n          });\n        } else {\n          _classPrivateFieldSet(this, _trackInfo, {\n            length: length\n          });\n        }\n      } else {\n        _classPrivateFieldSet(this, _trackInfo, {});\n      } // Points from segments:\n\n\n      for (var _i = 0; _i < totalSegments; _i++) {\n        var totalPointsInSegment = _classPrivateFieldGet(this, _reformatedTracks)[_i].points.length;\n\n        var segWithEle = _classPrivateFieldGet(this, _reformatedTracks)[_i].withEle;\n\n        var prevPoint = null;\n\n        for (var p = 0; p < totalPointsInSegment; p++) {\n          if (prevPoint === null) {\n            prevPoint = [this._rInt32(), this._rInt32(), this._rUint16() * 10];\n          } else {\n            prevPoint = [this._rInt16() + prevPoint[0], this._rInt16() + prevPoint[1], this._rUint16() * 10];\n          }\n\n          if (segWithEle) {\n            prevPoint = [].concat(_toConsumableArray(prevPoint), [this._rInt16()]);\n          }\n\n          _classPrivateFieldGet(this, _reformatedTracks)[_i].points[p] = prevPoint;\n        }\n      } // Points from waypoints:\n\n\n      var dec = new TextDecoder();\n\n      _classPrivateFieldSet(this, _waypoints, new Array(_classPrivateFieldGet(this, _totalWaypoints)));\n\n      for (var _i2 = 0; _i2 < _classPrivateFieldGet(this, _totalWaypoints); _i2++) {\n        var wpt = {\n          lon: this._rInt32(),\n          lat: this._rInt32()\n        };\n\n        switch (this._rUint8()) {\n          case encoded.withEle:\n            wpt = _objectSpread(_objectSpread({}, wpt), {}, {\n              ele: this._rInt16()\n            });\n            break;\n\n          case encoded.withoutEle:\n            break;\n\n          default:\n            throw \"Failed to load WebTrack: bad waypoint type\";\n        }\n\n        var arr = [];\n\n        for (var c = this._rUint8(); c != encoded.separator; c = this._rUint8()) {\n          arr.push(c);\n        }\n\n        var bytes = new Uint8Array(arr);\n        var sym = dec.decode(bytes);\n        arr = [];\n\n        for (var _c = this._rUint8(); _c != encoded.separator; _c = this._rUint8()) {\n          arr.push(_c);\n        }\n\n        bytes = new Uint8Array(arr);\n        var name = dec.decode(bytes);\n        _classPrivateFieldGet(this, _waypoints)[_i2] = _objectSpread(_objectSpread({}, wpt), {}, {\n          sym: sym,\n          name: name\n        });\n      }\n\n      return this;\n    }\n  }]);\n\n  return WebTrack;\n}(); //$FlowIgnore[invalid-export]\n\n\nif ((typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) === \"object\" && module.exports) {\n  //$FlowIgnore[invalid-export]\n  module.exports = WebTrack;\n}\n\n},{}]},{},[1])(1)\n});\n\n","// @flow\n\n/*!\n * MIT License\n *\n * Copyright (c) 2020 Clement\n * Copyright (c) 2018 Lucas Trebouet Voisin\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\ntype XMLDocument = any;\ntype Point = Array<any>;\ntype WayPoint = {\n    lat: number,\n    lon: number,\n    ele?: ?number,\n    sym?: string,\n    name?: string,\n    cumulDist?: number,\n};\ntype Segment = {\n    withEle: boolean,\n    points: Array<Point>,\n};\n\n/** Interface with the WebTrack file format. */\nclass WebTrack {\n    /** The WebTrack format name, constant. */\n    #formatName: string = \"webtrack-bin\";\n\n    /** The WebTrack format version, constant. */\n    #formatVersion: string = \"0.1.0\";\n\n    /** A list of segments in the WebTrack format. */\n    #reformatedTracks: Array<Segment> = [];\n\n    /** A list of waypoints in the WebTrack format. */\n    #waypoints: Array<WayPoint> = [];\n\n    /** Information about whole track (elevation statistics, etc.) */\n    #trackInfo: {\n        length: number,\n        min?: number,\n        max?: number,\n        gain?: number,\n        loss?: number,\n        trackPoints?: {\n            withEle: number,\n            withoutEle: number,\n        },\n    } = {};\n\n    /** Buffer used when loading a GPX string or a WebTrack buffer. */\n    #buffer: ?ArrayBuffer = null;\n\n    /** The size in bytes of the buffer. */\n    #bufferSize: number = 0;\n\n    /** The total amount of points containing elevation data. */\n    #pointsWithEle: number = 0;\n\n    /** The total amount of points not containing elevation data. */\n    #pointsWithoutEle: number = 0;\n\n    /** The current position in the buffer. */\n    #currentPos: number = 0;\n\n    /** The total amount of waypoints. */\n    #totalWaypoints: number = 0;\n\n    /** The DataView of the buffer. */\n    #view: DataView;\n\n    /**\n     * Load a GPX string and create a WebTrack buffer.\n     * @param gpxString The GPX string.\n     * @return this\n     */\n    loadGPX(gpxString: string): WebTrack {\n        this.#reformatedTracks = [];\n        this.#waypoints = [];\n        this.#pointsWithEle = 0;\n        this.#pointsWithoutEle = 0;\n        let domParser = new window.DOMParser();\n        let xmlSource: XMLDocument = domParser.parseFromString(\n            gpxString.trim(),\n            \"text/xml\"\n        );\n\n        let trks = [].slice.call(xmlSource.querySelectorAll(\"trk\"));\n        let prevPt = {};\n        let min = Number.POSITIVE_INFINITY,\n            max = Number.NEGATIVE_INFINITY,\n            gain = 0,\n            loss = 0;\n\n        trks.forEach((trk) => {\n            // loop over <trk/>\n            let trackpoints = [];\n            let trkpts = [].slice.call(trk.querySelectorAll(\"trkpt\"));\n\n            let segment: Segment = {};\n            let isFirst = true;\n            let prevEle = null;\n\n            trkpts.forEach((trkpt) => {\n                // loop over <trkpt/>\n                let pt: WayPoint = {};\n                pt.lat = parseFloat(trkpt.getAttribute(\"lat\"));\n                pt.lon = parseFloat(trkpt.getAttribute(\"lon\"));\n                pt.ele =\n                    parseFloat(this._getElementValue(trkpt, \"ele\")) || null;\n                if (\n                    Object.keys(prevPt).length === 0 &&\n                    prevPt.constructor === Object\n                ) {\n                    pt.cumulDist = 0.0;\n                } else {\n                    pt.cumulDist =\n                        //$FlowIgnore[unsafe-addition] operation with satisfying conditions\n                        prevPt.cumulDist + this.distanceBetween(prevPt, pt);\n                }\n                prevPt = { ...pt };\n                trackpoints.push(pt);\n                let webPt = this.gpsToWeb(pt.lon, pt.lat);\n\n                if (isFirst) {\n                    if (pt.ele === null) {\n                        segment.withEle = false;\n                        segment.points = [[...webPt, pt.cumulDist]];\n                    } else {\n                        segment.withEle = true;\n                        segment.points = [[...webPt, pt.cumulDist, pt.ele]];\n                    }\n                    isFirst = false;\n                } else {\n                    if (pt.ele === null) {\n                        if (segment.withEle) {\n                            // split\n                            this.#pointsWithEle += segment.points.length;\n                            this.#reformatedTracks.push(segment);\n                            segment = {}; // fresh segment\n                            segment.withEle = false;\n                            segment.points = [[...webPt, pt.cumulDist]];\n                        } else {\n                            segment.points.push([...webPt, pt.cumulDist]);\n                        }\n                    } else {\n                        if (!segment.withEle) {\n                            this.#pointsWithoutEle += segment.points.length;\n                            this.#reformatedTracks.push(segment);\n                            segment = {};\n                            segment.withEle = true;\n                            segment.points = [[...webPt, pt.cumulDist, pt.ele]];\n                        } else {\n                            segment.points.push([\n                                ...webPt,\n                                pt.cumulDist,\n                                pt.ele,\n                            ]);\n                        }\n                    }\n                }\n\n                if (pt.ele !== null) {\n                    if (prevEle !== null) {\n                        //$FlowIgnore[unsafe-addition]\n                        var diff = pt.ele - prevEle;\n                        if (diff < 0) {\n                            loss -= diff;\n                        } else if (diff > 0) {\n                            gain += diff;\n                        }\n                    }\n                    //$FlowIgnore[invalid-compare]\n                    if (min > pt.ele) {\n                        min = pt.ele;\n                    }\n                    //$FlowIgnore[invalid-compare]\n                    if (max < pt.ele) {\n                        max = pt.ele;\n                    }\n                    prevEle = pt.ele;\n                }\n            });\n\n            if (segment) {\n                if (segment.withEle) {\n                    this.#pointsWithEle += segment.points.length;\n                } else {\n                    this.#pointsWithoutEle += segment.points.length;\n                }\n                this.#reformatedTracks.push(segment);\n            }\n\n            if (this.#reformatedTracks.length > 255) {\n                throw \"Failed to load the GPX string: exceeding 255 segments\";\n            }\n        });\n\n        this.#trackInfo = {\n            length: this.getTrackLength(),\n            min: min,\n            max: max,\n            gain: gain,\n            loss: loss,\n        };\n\n        var wpts = [].slice.call(xmlSource.querySelectorAll(\"wpt\"));\n\n        wpts.forEach((wpt) => {\n            // loop over <wpt/>\n            let time = this._getElementValue(wpt, \"time\");\n            let coords = this.gpsToWeb(\n                parseFloat(wpt.getAttribute(\"lon\")),\n                parseFloat(wpt.getAttribute(\"lat\"))\n            );\n\n            this.#waypoints.push({\n                name: this._getElementValue(wpt, \"name\") || null,\n                sym: this._getElementValue(wpt, \"sym\") || null,\n                lon: coords[0],\n                lat: coords[1],\n                ele: parseFloat(this._getElementValue(wpt, \"ele\")) || null,\n                time: time == null ? null : new Date(time),\n            });\n        });\n\n        this.#totalWaypoints = this.#waypoints.length;\n\n        this.#bufferSize =\n            this._fmtArraySize() +\n            this._trksArraySize() +\n            this._wptsArraySize();\n\n        this.createBuffer();\n        return this;\n    }\n\n    /**\n     * Get value from a XML DOM element\n     *\n     * @param  {Element} parent - Parent DOM Element\n     * @param  {string} needle - Name of the searched element\n     *\n     * @return The element value\n     */\n    _getElementValue(parent: Element, needle: string): any {\n        let elem = parent.querySelector(needle);\n        if (elem != null) {\n            return elem.innerHTML != undefined\n                ? elem.innerHTML\n                : //$FlowIgnore[prop-missing]\n                  elem.childNodes[0].data;\n        }\n        return elem;\n    }\n\n    /**\n     * Compute the dstance between two points.\n     *\n     * @param  {WayPoint} wpt1 - A geographic point with lat and lon properties\n     * @param  {WayPoint} wpt2 - A geographic point with lat and lon properties\n     *\n     * @returns {float} The distance between the two points\n     */\n    distanceBetween(wpt1: WayPoint, wpt2: WayPoint): number {\n        let latlng1 = {};\n        latlng1.lat = wpt1.lat;\n        latlng1.lon = wpt1.lon;\n        let latlng2 = {};\n        latlng2.lat = wpt2.lat;\n        latlng2.lon = wpt2.lon;\n        var rad = Math.PI / 180,\n            lat1 = latlng1.lat * rad,\n            lat2 = latlng2.lat * rad,\n            sinDLat = Math.sin(((latlng2.lat - latlng1.lat) * rad) / 2),\n            sinDLon = Math.sin(((latlng2.lon - latlng1.lon) * rad) / 2),\n            a =\n                sinDLat * sinDLat +\n                Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,\n            c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return 6371008 * c;\n    }\n\n    /**\n     * Returns the first characters that should be in the WebTrack file.\n     * Example: 'webtrack-bin:0.1.2:'\n     * @return ASCII characters.\n     */\n    _fmtText(): string {\n        return `${this.#formatName}:${this.#formatVersion}:`;\n    }\n\n    /**\n     * Returns the length in bytes of the \"Format Information\" section.\n     * @return Number of bytes.\n     */\n    _fmtArraySize(): number {\n        return this._fmtText().length + 3;\n    }\n\n    /**\n     * Returns the length in bytes of the \"Segment Headers\",\n     * plus the \"Track Information\", plus the \"Segment\" sections.\n     * @return Number of bytes.\n     */\n    _trksArraySize(): number {\n        const totalSegments = this.#reformatedTracks.length;\n        let trksArraySize = 0;\n\n        if (totalSegments > 0) {\n            // segment headers:\n            trksArraySize += totalSegments * 5;\n            // tracks info (length):\n            trksArraySize += 4;\n            if (this.#pointsWithEle > 0) {\n                // tracks info (ele min/max/gain/loss):\n                trksArraySize += 12;\n            }\n\n            trksArraySize +=\n                totalSegments * 4 +\n                this.#pointsWithoutEle * 6 +\n                this.#pointsWithEle * 8;\n        }\n\n        return trksArraySize;\n    }\n\n    /**\n     * Returns the length in bytes of the \"Waypoints\" section.\n     * @return Number of bytes.\n     */\n    _wptsArraySize(): number {\n        let wptsArraySize = 0;\n\n        this.#waypoints.forEach((waypoint) => {\n            wptsArraySize +=\n                11 +\n                (waypoint.ele ? 2 : 0) +\n                (waypoint.sym ? waypoint.sym.length : 0) +\n                (waypoint.name ? waypoint.name.length : 0);\n        });\n\n        return wptsArraySize;\n    }\n\n    /**\n     * Returns true if there is at least one point with elevation data.\n     * @return False if there isn't a single point with elevation, true otherwise.\n     */\n    someTracksWithEle(): boolean {\n        return this.#pointsWithEle > 0;\n    }\n\n    /**\n     * Returns the size of the buffer.\n     * @return Number of bytes.\n     */\n    getBufferSize(): number {\n        return this.#bufferSize;\n    }\n\n    /**\n     * Append a uint8 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n    _wUint8(data: number) {\n        this.#view.setUint8(this.#currentPos++, data);\n    }\n\n    /**\n     * Read a uint8 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The byte from the buffer.\n     */\n    _rUint8(): number {\n        return this.#view.getUint8(this.#currentPos++);\n    }\n\n    /**\n     * Append a uint16 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n    _wUint16(data: number) {\n        this.#view.setUint16(this.#currentPos, data, false);\n        this.#currentPos += 2;\n    }\n\n    /**\n     * Read a uint16 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The bytes from the buffer.\n     */\n    _rUint16(): number {\n        let pos = this.#currentPos;\n        this.#currentPos += 2;\n        return this.#view.getUint16(pos, false);\n    }\n\n    /**\n     * Append a int16 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n    _wInt16(data: number) {\n        this.#view.setInt16(this.#currentPos, data, false);\n        this.#currentPos += 2;\n    }\n\n    /**\n     * Read a int16 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The bytes from the buffer.\n     */\n    _rInt16(): number {\n        let pos = this.#currentPos;\n        this.#currentPos += 2;\n        return this.#view.getInt16(pos, false);\n    }\n\n    /**\n     * Append a uint32 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n    _wUint32(data: number) {\n        this.#view.setUint32(this.#currentPos, data, false);\n        this.#currentPos += 4;\n    }\n\n    /**\n     * Read a uint32 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The bytes from the buffer.\n     */\n    _rUint32(): number {\n        let pos = this.#currentPos;\n        this.#currentPos += 4;\n        return this.#view.getUint32(pos, false);\n    }\n\n    /**\n     * Append a int32 element to the buffer and increment the current position.\n     * @param data The element to add into the buffer.\n     */\n    _wInt32(data: number) {\n        this.#view.setInt32(this.#currentPos, data, false);\n        this.#currentPos += 4;\n    }\n\n    /**\n     * Read a int32 element from the buffer at the current position and\n     * increment the cursor.\n     * @return The bytes from the buffer.\n     */\n    _rInt32(): number {\n        let pos = this.#currentPos;\n        this.#currentPos += 4;\n        return this.#view.getInt32(pos, false);\n    }\n\n    /**\n     * Projection of a GPS point (EPSG:4326) into the Web Mercator (EPSG:3857).\n     * Formula based on:\n     * Title: Implementation Practice Web Mercator Map Projection\n     * Reference: NGA.SIG.0011_1.0.0_WEBMERC, 2014-02-18\n     * Author: National Geospatial Intelligence Agency (NGA)\n     * @param lon GPS longitude\n     * @param lat GPS latitude\n     * @return Web Mercator coordinates [easting, northing]\n     */\n    gpsToWeb(lon: number, lat: number): Point {\n        const rad = Math.PI / 180;\n        // ellipsoid semi-major axis [WSG 84 = 6378137m]:\n        const a = 6378137;\n        // no parseInt to reduce drift when substracting coordinates:\n        return [\n            // easting coordinate in the Web Mercator:\n            lon * a * rad,\n            // northing coordinate in the Web Mercator:\n            a * Math.atanh(Math.sin(lat * rad)),\n        ];\n    }\n\n    /**\n     * Returns essential information about the track.\n     */\n    getTrackInfo(): {} {\n        return {\n            ...this.#trackInfo,\n            trackPoints: {\n                withEle: this.#pointsWithEle,\n                withoutEle: this.#pointsWithoutEle,\n            },\n        };\n    }\n\n    /**\n     * Returns an array of segments in the WebTrack format.\n     */\n    getTrack(): Array<Segment> {\n        return this.#reformatedTracks;\n    }\n\n    /**\n     * Returns an array of waypoints in the WebTrack format.\n     */\n    getWaypoints(): Array<WayPoint> {\n        return this.#waypoints;\n    }\n\n    /**\n     * Returns the length of the whole track.\n     */\n    getTrackLength(): number {\n        const lastSegment = this.#reformatedTracks[\n            this.#reformatedTracks.length - 1\n        ].points;\n        return lastSegment[lastSegment.length - 1][2];\n    }\n\n    /**\n     * Create a WebTrack buffer with the data fetched from the GPX string.\n     * @return A WebTrack buffer ready to be stored.\n     */\n    createBuffer(): WebTrack {\n        if (this.#bufferSize == 0) {\n            throw \"Failed to create the WebTrack buffer: empty buffer\";\n        }\n        this.#buffer = new ArrayBuffer(this.#bufferSize);\n        this.#view = new DataView(this.#buffer);\n        const enc = new TextEncoder();\n        const encoded = {\n            withEle: enc.encode(\"E\")[0],\n            withoutEle: enc.encode(\"F\")[0],\n            separator: enc.encode(\"\\n\")[0],\n        };\n\n        // Format Information:\n\n        const fmtText = enc.encode(this._fmtText());\n        this.#currentPos = 0;\n\n        fmtText.forEach((c) => {\n            this._wUint8(c);\n        });\n        const totalSegments = this.#reformatedTracks.length;\n        if (totalSegments > 255) {\n            throw \"Failed to create the WebTrack buffer: too many segments\";\n        }\n        this._wUint8(totalSegments);\n        if (this.#totalWaypoints > 65535) {\n            throw \"Failed to create the WebTrack buffer: too many waypoints\";\n        }\n        this._wUint16(this.#totalWaypoints);\n\n        // Segment Headers:\n\n        this.#reformatedTracks.forEach((segment) => {\n            let c = segment.withEle ? encoded.withEle : encoded.withoutEle;\n            this._wUint8(c);\n            // Number of points written in big-endian:\n            this._wUint32(segment.points.length);\n        });\n\n        // Track Information:\n\n        this._wUint32(Math.round(this.#trackInfo.length));\n        if (this.someTracksWithEle()) {\n            //$FlowIgnore[incompatible-call] condition satisfied\n            this._wInt16(Math.round(this.#trackInfo.min));\n            //$FlowIgnore[incompatible-call] condition satisfied\n            this._wInt16(Math.round(this.#trackInfo.max));\n            //$FlowIgnore[incompatible-call] condition satisfied\n            this._wUint32(Math.round(this.#trackInfo.gain));\n            //$FlowIgnore[incompatible-call] condition satisfied\n            this._wUint32(Math.round(this.#trackInfo.loss));\n        }\n\n        // Points from segments:\n\n        this.#reformatedTracks.forEach((segment) => {\n            let prevPoint = null;\n            segment.points.forEach((point) => {\n                if (prevPoint === null) {\n                    this._wInt32(Math.round(point[0]));\n                    this._wInt32(Math.round(point[1]));\n\n                    // cumulated distance:\n                    this._wUint16(Math.round(point[2] / 10));\n                } else {\n                    // rounding positions before diff to avoid drift\n                    const deltaX =\n                            Math.round(point[0]) - Math.round(prevPoint[0]),\n                        deltaY =\n                            Math.round(point[1]) - Math.round(prevPoint[1]);\n\n                    const minDelta = -32768,\n                        maxDelta = 32767;\n                    if (\n                        deltaX > maxDelta ||\n                        deltaX < minDelta ||\n                        deltaY > maxDelta ||\n                        deltaY < minDelta\n                    ) {\n                        throw \"Failed to create the WebTrack buffer: offset out or range\";\n                    }\n                    this._wInt16(Math.round(deltaX));\n                    this._wInt16(Math.round(deltaY));\n                    this._wUint16(Math.round(point[2] / 10));\n                }\n                prevPoint = point;\n\n                if (segment.withEle) {\n                    this._wInt16(Math.round(point[3]));\n                }\n            });\n        });\n\n        // Points from waypoints:\n\n        this.#waypoints.forEach((waypoint) => {\n            this._wInt32(Math.round(waypoint.lon));\n            this._wInt32(Math.round(waypoint.lat));\n            this._wUint8(waypoint.ele ? encoded.withEle : encoded.withoutEle);\n            if (waypoint.ele) {\n                this._wInt16(Math.round(waypoint.ele));\n            }\n            if (waypoint.sym) {\n                const symText = enc.encode(waypoint.sym);\n                symText.forEach((c) => {\n                    this._wUint8(c);\n                });\n            }\n            this._wUint8(encoded.separator);\n            if (waypoint.name) {\n                const nameText = enc.encode(waypoint.name);\n                nameText.forEach((c) => {\n                    this._wUint8(c);\n                });\n            }\n            this._wUint8(encoded.separator);\n        });\n\n        if (this.#currentPos != this.#bufferSize) {\n            throw \"Failed to create the WebTrack buffer: final position and buffer size mismatch\";\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns the output buffer if not null, otherwise the input buffer.\n     * @return Buffer or null/undefined if both the input and the output buffer are null/undefined.\n     */\n    getBuffer(): ?ArrayBuffer {\n        return this.#buffer;\n    }\n\n    /**\n     * Check if the first bytes of the input buffer match the file format.\n     * Returns false if the input buffer is null or undefined.\n     * @see loadWebTrack()\n     * @return True if match, false otherwise\n     */\n    _formatInfoPass(): boolean {\n        if (!this.#buffer) {\n            return false;\n        }\n        const dec = new TextDecoder();\n        const fmtInput = new Uint8Array(\n            this.#buffer,\n            0,\n            this._fmtText().length\n        );\n        return this._fmtText() == dec.decode(fmtInput);\n    }\n\n    /**\n     * Load a buffer containing the WebTrack.\n     * The file format and version must be as defined by this class.\n     * @param webtrackBytes The WebTrack buffer\n     * @return this\n     */\n    loadWebTrack(webtrackBytes: ArrayBuffer): WebTrack {\n        if (!webtrackBytes) {\n            throw \"Failed to load WebTrack: bad input buffer\";\n        }\n        this.#buffer = webtrackBytes;\n        let typedBuffer = new Uint8Array(webtrackBytes);\n        this.#bufferSize = typedBuffer.length;\n\n        // Format Information:\n\n        if (!this._formatInfoPass()) {\n            throw \"Failed to load WebTrack: bad file format\";\n        }\n\n        const enc = new TextEncoder();\n        const encoded = {\n            withEle: enc.encode(\"E\")[0],\n            withoutEle: enc.encode(\"F\")[0],\n            separator: enc.encode(\"\\n\")[0],\n        };\n        //$FlowIgnore[incompatible-call] error thrown earlier if the buffer is null\n        this.#view = new DataView(this.#buffer);\n        this.#currentPos = this._fmtText().length;\n        const totalSegments = this._rUint8();\n        this.#totalWaypoints = this._rUint16();\n        this.#reformatedTracks = new Array(totalSegments);\n        this.#pointsWithEle = 0;\n        this.#pointsWithoutEle = 0;\n\n        // Segment Headers:\n\n        for (let i = 0; i < totalSegments; i++) {\n            let currSegType = this._rUint8(),\n                points = this._rUint32(),\n                withEle;\n            switch (currSegType) {\n                case encoded.withEle:\n                    withEle = true;\n                    this.#pointsWithEle += points;\n                    break;\n                case encoded.withoutEle:\n                    withEle = false;\n                    this.#pointsWithoutEle += points;\n                    break;\n                default:\n                    throw \"Failed to load WebTrack: bad segment type\";\n            }\n            this.#reformatedTracks[i] = {\n                withEle: withEle,\n                points: new Array(points),\n            };\n        }\n\n        // Track Information:\n\n        if (totalSegments) {\n            let length = this._rUint32();\n            if (this.someTracksWithEle()) {\n                this.#trackInfo = {\n                    length: length,\n                    min: this._rInt16(),\n                    max: this._rInt16(),\n                    gain: this._rUint32(),\n                    loss: this._rUint32(),\n                };\n            } else {\n                this.#trackInfo = {\n                    length: length,\n                };\n            }\n        } else {\n            this.#trackInfo = {};\n        }\n\n        // Points from segments:\n\n        for (let i = 0; i < totalSegments; i++) {\n            const totalPointsInSegment = this.#reformatedTracks[i].points\n                .length;\n            const segWithEle = this.#reformatedTracks[i].withEle;\n            let prevPoint = null;\n\n            for (let p = 0; p < totalPointsInSegment; p++) {\n                if (prevPoint === null) {\n                    prevPoint = [\n                        this._rInt32(),\n                        this._rInt32(),\n                        this._rUint16() * 10,\n                    ];\n                } else {\n                    prevPoint = [\n                        this._rInt16() + prevPoint[0],\n                        this._rInt16() + prevPoint[1],\n                        this._rUint16() * 10,\n                    ];\n                }\n                if (segWithEle) {\n                    prevPoint = [...prevPoint, this._rInt16()];\n                }\n                this.#reformatedTracks[i].points[p] = prevPoint;\n            }\n        }\n\n        // Points from waypoints:\n\n        const dec = new TextDecoder();\n        this.#waypoints = new Array(this.#totalWaypoints);\n        for (let i = 0; i < this.#totalWaypoints; i++) {\n            let wpt = {\n                lon: this._rInt32(),\n                lat: this._rInt32(),\n            };\n\n            switch (this._rUint8()) {\n                case encoded.withEle:\n                    wpt = { ...wpt, ele: this._rInt16() };\n                    break;\n                case encoded.withoutEle:\n                    break;\n                default:\n                    throw \"Failed to load WebTrack: bad waypoint type\";\n            }\n\n            let arr = [];\n            for (\n                let c = this._rUint8();\n                c != encoded.separator;\n                c = this._rUint8()\n            ) {\n                arr.push(c);\n            }\n            let bytes = new Uint8Array(arr);\n            let sym = dec.decode(bytes);\n\n            arr = [];\n            for (\n                let c = this._rUint8();\n                c != encoded.separator;\n                c = this._rUint8()\n            ) {\n                arr.push(c);\n            }\n            bytes = new Uint8Array(arr);\n            let name = dec.decode(bytes);\n\n            this.#waypoints[i] = { ...wpt, sym: sym, name: name };\n        }\n\n        return this;\n    }\n}\n\n//$FlowIgnore[invalid-export]\nif (typeof module === \"object\" && module.exports) {\n    //$FlowIgnore[invalid-export]\n    module.exports = WebTrack;\n}\n"]}